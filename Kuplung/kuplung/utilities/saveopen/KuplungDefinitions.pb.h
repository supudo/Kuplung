// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: KuplungDefinitions.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_KuplungDefinitions_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_KuplungDefinitions_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_KuplungDefinitions_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_KuplungDefinitions_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_KuplungDefinitions_2eproto;
namespace KuplungApp {
class FBEntity;
struct FBEntityDefaultTypeInternal;
extern FBEntityDefaultTypeInternal _FBEntity_default_instance_;
class MaterialColor;
struct MaterialColorDefaultTypeInternal;
extern MaterialColorDefaultTypeInternal _MaterialColor_default_instance_;
class Mesh;
struct MeshDefaultTypeInternal;
extern MeshDefaultTypeInternal _Mesh_default_instance_;
class MeshMaterialTextureImage;
struct MeshMaterialTextureImageDefaultTypeInternal;
extern MeshMaterialTextureImageDefaultTypeInternal _MeshMaterialTextureImage_default_instance_;
class MeshModelMaterial;
struct MeshModelMaterialDefaultTypeInternal;
extern MeshModelMaterialDefaultTypeInternal _MeshModelMaterial_default_instance_;
class ObjectCoordinate;
struct ObjectCoordinateDefaultTypeInternal;
extern ObjectCoordinateDefaultTypeInternal _ObjectCoordinate_default_instance_;
class Vec2;
struct Vec2DefaultTypeInternal;
extern Vec2DefaultTypeInternal _Vec2_default_instance_;
class Vec3;
struct Vec3DefaultTypeInternal;
extern Vec3DefaultTypeInternal _Vec3_default_instance_;
class Vec4;
struct Vec4DefaultTypeInternal;
extern Vec4DefaultTypeInternal _Vec4_default_instance_;
}  // namespace KuplungApp
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace KuplungApp {

// ===================================================================


// -------------------------------------------------------------------

class Vec4 final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KuplungApp.Vec4) */ {
 public:
  inline Vec4() : Vec4(nullptr) {}
  ~Vec4() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Vec4(::google::protobuf::internal::ConstantInitialized);

  inline Vec4(const Vec4& from)
      : Vec4(nullptr, from) {}
  Vec4(Vec4&& from) noexcept
    : Vec4() {
    *this = ::std::move(from);
  }

  inline Vec4& operator=(const Vec4& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vec4& operator=(Vec4&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vec4& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vec4* internal_default_instance() {
    return reinterpret_cast<const Vec4*>(
               &_Vec4_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Vec4& a, Vec4& b) {
    a.Swap(&b);
  }
  inline void Swap(Vec4* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vec4* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vec4* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vec4>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Vec4& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Vec4& from) {
    Vec4::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Vec4* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "KuplungApp.Vec4";
  }
  protected:
  explicit Vec4(::google::protobuf::Arena* arena);
  Vec4(::google::protobuf::Arena* arena, const Vec4& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
    kWFieldNumber = 4,
  };
  // required float x = 1;
  bool has_x() const;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // required float y = 2;
  bool has_y() const;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // required float z = 3;
  bool has_z() const;
  void clear_z() ;
  float z() const;
  void set_z(float value);

  private:
  float _internal_z() const;
  void _internal_set_z(float value);

  public:
  // required float w = 4;
  bool has_w() const;
  void clear_w() ;
  float w() const;
  void set_w(float value);

  private:
  float _internal_w() const;
  void _internal_set_w(float value);

  public:
  // @@protoc_insertion_point(class_scope:KuplungApp.Vec4)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    float x_;
    float y_;
    float z_;
    float w_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KuplungDefinitions_2eproto;
};// -------------------------------------------------------------------

class Vec3 final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KuplungApp.Vec3) */ {
 public:
  inline Vec3() : Vec3(nullptr) {}
  ~Vec3() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Vec3(::google::protobuf::internal::ConstantInitialized);

  inline Vec3(const Vec3& from)
      : Vec3(nullptr, from) {}
  Vec3(Vec3&& from) noexcept
    : Vec3() {
    *this = ::std::move(from);
  }

  inline Vec3& operator=(const Vec3& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vec3& operator=(Vec3&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vec3& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vec3* internal_default_instance() {
    return reinterpret_cast<const Vec3*>(
               &_Vec3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Vec3& a, Vec3& b) {
    a.Swap(&b);
  }
  inline void Swap(Vec3* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vec3* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vec3* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vec3>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Vec3& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Vec3& from) {
    Vec3::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Vec3* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "KuplungApp.Vec3";
  }
  protected:
  explicit Vec3(::google::protobuf::Arena* arena);
  Vec3(::google::protobuf::Arena* arena, const Vec3& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // required float x = 1;
  bool has_x() const;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // required float y = 2;
  bool has_y() const;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // required float z = 3;
  bool has_z() const;
  void clear_z() ;
  float z() const;
  void set_z(float value);

  private:
  float _internal_z() const;
  void _internal_set_z(float value);

  public:
  // @@protoc_insertion_point(class_scope:KuplungApp.Vec3)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    float x_;
    float y_;
    float z_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KuplungDefinitions_2eproto;
};// -------------------------------------------------------------------

class Vec2 final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KuplungApp.Vec2) */ {
 public:
  inline Vec2() : Vec2(nullptr) {}
  ~Vec2() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Vec2(::google::protobuf::internal::ConstantInitialized);

  inline Vec2(const Vec2& from)
      : Vec2(nullptr, from) {}
  Vec2(Vec2&& from) noexcept
    : Vec2() {
    *this = ::std::move(from);
  }

  inline Vec2& operator=(const Vec2& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vec2& operator=(Vec2&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vec2& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vec2* internal_default_instance() {
    return reinterpret_cast<const Vec2*>(
               &_Vec2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Vec2& a, Vec2& b) {
    a.Swap(&b);
  }
  inline void Swap(Vec2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vec2* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vec2* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vec2>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Vec2& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Vec2& from) {
    Vec2::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Vec2* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "KuplungApp.Vec2";
  }
  protected:
  explicit Vec2(::google::protobuf::Arena* arena);
  Vec2(::google::protobuf::Arena* arena, const Vec2& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // required float x = 1;
  bool has_x() const;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // required float y = 2;
  bool has_y() const;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // @@protoc_insertion_point(class_scope:KuplungApp.Vec2)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    float x_;
    float y_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KuplungDefinitions_2eproto;
};// -------------------------------------------------------------------

class ObjectCoordinate final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KuplungApp.ObjectCoordinate) */ {
 public:
  inline ObjectCoordinate() : ObjectCoordinate(nullptr) {}
  ~ObjectCoordinate() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ObjectCoordinate(::google::protobuf::internal::ConstantInitialized);

  inline ObjectCoordinate(const ObjectCoordinate& from)
      : ObjectCoordinate(nullptr, from) {}
  ObjectCoordinate(ObjectCoordinate&& from) noexcept
    : ObjectCoordinate() {
    *this = ::std::move(from);
  }

  inline ObjectCoordinate& operator=(const ObjectCoordinate& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectCoordinate& operator=(ObjectCoordinate&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectCoordinate& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectCoordinate* internal_default_instance() {
    return reinterpret_cast<const ObjectCoordinate*>(
               &_ObjectCoordinate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ObjectCoordinate& a, ObjectCoordinate& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectCoordinate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectCoordinate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectCoordinate* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObjectCoordinate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ObjectCoordinate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ObjectCoordinate& from) {
    ObjectCoordinate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ObjectCoordinate* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "KuplungApp.ObjectCoordinate";
  }
  protected:
  explicit ObjectCoordinate(::google::protobuf::Arena* arena);
  ObjectCoordinate(::google::protobuf::Arena* arena, const ObjectCoordinate& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnimateFieldNumber = 1,
    kPointFieldNumber = 2,
  };
  // required bool animate = 1;
  bool has_animate() const;
  void clear_animate() ;
  bool animate() const;
  void set_animate(bool value);

  private:
  bool _internal_animate() const;
  void _internal_set_animate(bool value);

  public:
  // required float point = 2;
  bool has_point() const;
  void clear_point() ;
  float point() const;
  void set_point(float value);

  private:
  float _internal_point() const;
  void _internal_set_point(float value);

  public:
  // @@protoc_insertion_point(class_scope:KuplungApp.ObjectCoordinate)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    bool animate_;
    float point_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KuplungDefinitions_2eproto;
};// -------------------------------------------------------------------

class MeshMaterialTextureImage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KuplungApp.MeshMaterialTextureImage) */ {
 public:
  inline MeshMaterialTextureImage() : MeshMaterialTextureImage(nullptr) {}
  ~MeshMaterialTextureImage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MeshMaterialTextureImage(::google::protobuf::internal::ConstantInitialized);

  inline MeshMaterialTextureImage(const MeshMaterialTextureImage& from)
      : MeshMaterialTextureImage(nullptr, from) {}
  MeshMaterialTextureImage(MeshMaterialTextureImage&& from) noexcept
    : MeshMaterialTextureImage() {
    *this = ::std::move(from);
  }

  inline MeshMaterialTextureImage& operator=(const MeshMaterialTextureImage& from) {
    CopyFrom(from);
    return *this;
  }
  inline MeshMaterialTextureImage& operator=(MeshMaterialTextureImage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MeshMaterialTextureImage& default_instance() {
    return *internal_default_instance();
  }
  static inline const MeshMaterialTextureImage* internal_default_instance() {
    return reinterpret_cast<const MeshMaterialTextureImage*>(
               &_MeshMaterialTextureImage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MeshMaterialTextureImage& a, MeshMaterialTextureImage& b) {
    a.Swap(&b);
  }
  inline void Swap(MeshMaterialTextureImage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MeshMaterialTextureImage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MeshMaterialTextureImage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MeshMaterialTextureImage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MeshMaterialTextureImage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MeshMaterialTextureImage& from) {
    MeshMaterialTextureImage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MeshMaterialTextureImage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "KuplungApp.MeshMaterialTextureImage";
  }
  protected:
  explicit MeshMaterialTextureImage(::google::protobuf::Arena* arena);
  MeshMaterialTextureImage(::google::protobuf::Arena* arena, const MeshMaterialTextureImage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommandsFieldNumber = 6,
    kFilenameFieldNumber = 1,
    kImageFieldNumber = 2,
    kWidthFieldNumber = 3,
    kHeightFieldNumber = 4,
    kUseTextureFieldNumber = 5,
  };
  // repeated string Commands = 6;
  int commands_size() const;
  private:
  int _internal_commands_size() const;

  public:
  void clear_commands() ;
  const std::string& commands(int index) const;
  std::string* mutable_commands(int index);
  void set_commands(int index, const std::string& value);
  void set_commands(int index, std::string&& value);
  void set_commands(int index, const char* value);
  void set_commands(int index, const char* value, std::size_t size);
  void set_commands(int index, absl::string_view value);
  std::string* add_commands();
  void add_commands(const std::string& value);
  void add_commands(std::string&& value);
  void add_commands(const char* value);
  void add_commands(const char* value, std::size_t size);
  void add_commands(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& commands() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_commands();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_commands() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_commands();

  public:
  // required string Filename = 1;
  bool has_filename() const;
  void clear_filename() ;
  const std::string& filename() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_filename(Arg_&& arg, Args_... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* value);

  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(
      const std::string& value);
  std::string* _internal_mutable_filename();

  public:
  // required string Image = 2;
  bool has_image() const;
  void clear_image() ;
  const std::string& image() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_image(Arg_&& arg, Args_... args);
  std::string* mutable_image();
  PROTOBUF_NODISCARD std::string* release_image();
  void set_allocated_image(std::string* value);

  private:
  const std::string& _internal_image() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image(
      const std::string& value);
  std::string* _internal_mutable_image();

  public:
  // required int32 Width = 3;
  bool has_width() const;
  void clear_width() ;
  ::int32_t width() const;
  void set_width(::int32_t value);

  private:
  ::int32_t _internal_width() const;
  void _internal_set_width(::int32_t value);

  public:
  // required int32 Height = 4;
  bool has_height() const;
  void clear_height() ;
  ::int32_t height() const;
  void set_height(::int32_t value);

  private:
  ::int32_t _internal_height() const;
  void _internal_set_height(::int32_t value);

  public:
  // required bool UseTexture = 5;
  bool has_usetexture() const;
  void clear_usetexture() ;
  bool usetexture() const;
  void set_usetexture(bool value);

  private:
  bool _internal_usetexture() const;
  void _internal_set_usetexture(bool value);

  public:
  // @@protoc_insertion_point(class_scope:KuplungApp.MeshMaterialTextureImage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      65, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> commands_;
    ::google::protobuf::internal::ArenaStringPtr filename_;
    ::google::protobuf::internal::ArenaStringPtr image_;
    ::int32_t width_;
    ::int32_t height_;
    bool usetexture_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KuplungDefinitions_2eproto;
};// -------------------------------------------------------------------

class FBEntity final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KuplungApp.FBEntity) */ {
 public:
  inline FBEntity() : FBEntity(nullptr) {}
  ~FBEntity() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FBEntity(::google::protobuf::internal::ConstantInitialized);

  inline FBEntity(const FBEntity& from)
      : FBEntity(nullptr, from) {}
  FBEntity(FBEntity&& from) noexcept
    : FBEntity() {
    *this = ::std::move(from);
  }

  inline FBEntity& operator=(const FBEntity& from) {
    CopyFrom(from);
    return *this;
  }
  inline FBEntity& operator=(FBEntity&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FBEntity& default_instance() {
    return *internal_default_instance();
  }
  static inline const FBEntity* internal_default_instance() {
    return reinterpret_cast<const FBEntity*>(
               &_FBEntity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(FBEntity& a, FBEntity& b) {
    a.Swap(&b);
  }
  inline void Swap(FBEntity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FBEntity* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FBEntity* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FBEntity>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FBEntity& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const FBEntity& from) {
    FBEntity::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FBEntity* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "KuplungApp.FBEntity";
  }
  protected:
  explicit FBEntity(::google::protobuf::Arena* arena);
  FBEntity(::google::protobuf::Arena* arena, const FBEntity& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 2,
    kTitleFieldNumber = 3,
    kExtensionFieldNumber = 4,
    kModifiedDateFieldNumber = 5,
    kSizeFieldNumber = 6,
    kIsFileFieldNumber = 1,
  };
  // required string path = 2;
  bool has_path() const;
  void clear_path() ;
  const std::string& path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_path(Arg_&& arg, Args_... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* value);

  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(
      const std::string& value);
  std::string* _internal_mutable_path();

  public:
  // required string title = 3;
  bool has_title() const;
  void clear_title() ;
  const std::string& title() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* value);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // required string extension = 4;
  bool has_extension() const;
  void clear_extension() ;
  const std::string& extension() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_extension(Arg_&& arg, Args_... args);
  std::string* mutable_extension();
  PROTOBUF_NODISCARD std::string* release_extension();
  void set_allocated_extension(std::string* value);

  private:
  const std::string& _internal_extension() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extension(
      const std::string& value);
  std::string* _internal_mutable_extension();

  public:
  // required string modifiedDate = 5;
  bool has_modifieddate() const;
  void clear_modifieddate() ;
  const std::string& modifieddate() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_modifieddate(Arg_&& arg, Args_... args);
  std::string* mutable_modifieddate();
  PROTOBUF_NODISCARD std::string* release_modifieddate();
  void set_allocated_modifieddate(std::string* value);

  private:
  const std::string& _internal_modifieddate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modifieddate(
      const std::string& value);
  std::string* _internal_mutable_modifieddate();

  public:
  // required string size = 6;
  bool has_size() const;
  void clear_size() ;
  const std::string& size() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_size(Arg_&& arg, Args_... args);
  std::string* mutable_size();
  PROTOBUF_NODISCARD std::string* release_size();
  void set_allocated_size(std::string* value);

  private:
  const std::string& _internal_size() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_size(
      const std::string& value);
  std::string* _internal_mutable_size();

  public:
  // required bool isFile = 1;
  bool has_isfile() const;
  void clear_isfile() ;
  bool isfile() const;
  void set_isfile(bool value);

  private:
  bool _internal_isfile() const;
  void _internal_set_isfile(bool value);

  public:
  // @@protoc_insertion_point(class_scope:KuplungApp.FBEntity)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      62, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr path_;
    ::google::protobuf::internal::ArenaStringPtr title_;
    ::google::protobuf::internal::ArenaStringPtr extension_;
    ::google::protobuf::internal::ArenaStringPtr modifieddate_;
    ::google::protobuf::internal::ArenaStringPtr size_;
    bool isfile_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KuplungDefinitions_2eproto;
};// -------------------------------------------------------------------

class MeshModelMaterial final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KuplungApp.MeshModelMaterial) */ {
 public:
  inline MeshModelMaterial() : MeshModelMaterial(nullptr) {}
  ~MeshModelMaterial() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MeshModelMaterial(::google::protobuf::internal::ConstantInitialized);

  inline MeshModelMaterial(const MeshModelMaterial& from)
      : MeshModelMaterial(nullptr, from) {}
  MeshModelMaterial(MeshModelMaterial&& from) noexcept
    : MeshModelMaterial() {
    *this = ::std::move(from);
  }

  inline MeshModelMaterial& operator=(const MeshModelMaterial& from) {
    CopyFrom(from);
    return *this;
  }
  inline MeshModelMaterial& operator=(MeshModelMaterial&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MeshModelMaterial& default_instance() {
    return *internal_default_instance();
  }
  static inline const MeshModelMaterial* internal_default_instance() {
    return reinterpret_cast<const MeshModelMaterial*>(
               &_MeshModelMaterial_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(MeshModelMaterial& a, MeshModelMaterial& b) {
    a.Swap(&b);
  }
  inline void Swap(MeshModelMaterial* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MeshModelMaterial* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MeshModelMaterial* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MeshModelMaterial>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MeshModelMaterial& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MeshModelMaterial& from) {
    MeshModelMaterial::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MeshModelMaterial* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "KuplungApp.MeshModelMaterial";
  }
  protected:
  explicit MeshModelMaterial(::google::protobuf::Arena* arena);
  MeshModelMaterial(::google::protobuf::Arena* arena, const MeshModelMaterial& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaterialTitleFieldNumber = 2,
    kAmbientColorFieldNumber = 3,
    kDiffuseColorFieldNumber = 4,
    kSpecularColorFieldNumber = 5,
    kEmissionColorFieldNumber = 6,
    kTextureAmbientFieldNumber = 11,
    kTextureDiffuseFieldNumber = 12,
    kTextureSpecularFieldNumber = 13,
    kTextureSpecularExpFieldNumber = 14,
    kTextureDissolveFieldNumber = 15,
    kTextureBumpFieldNumber = 16,
    kTextureDisplacementFieldNumber = 17,
    kMaterialIDFieldNumber = 1,
    kSpecularExpFieldNumber = 7,
    kTransparencyFieldNumber = 8,
    kIlluminationModeFieldNumber = 9,
    kOpticalDensityFieldNumber = 10,
  };
  // required string MaterialTitle = 2;
  bool has_materialtitle() const;
  void clear_materialtitle() ;
  const std::string& materialtitle() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_materialtitle(Arg_&& arg, Args_... args);
  std::string* mutable_materialtitle();
  PROTOBUF_NODISCARD std::string* release_materialtitle();
  void set_allocated_materialtitle(std::string* value);

  private:
  const std::string& _internal_materialtitle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_materialtitle(
      const std::string& value);
  std::string* _internal_mutable_materialtitle();

  public:
  // required .KuplungApp.Vec3 AmbientColor = 3;
  bool has_ambientcolor() const;
  void clear_ambientcolor() ;
  const ::KuplungApp::Vec3& ambientcolor() const;
  PROTOBUF_NODISCARD ::KuplungApp::Vec3* release_ambientcolor();
  ::KuplungApp::Vec3* mutable_ambientcolor();
  void set_allocated_ambientcolor(::KuplungApp::Vec3* value);
  void unsafe_arena_set_allocated_ambientcolor(::KuplungApp::Vec3* value);
  ::KuplungApp::Vec3* unsafe_arena_release_ambientcolor();

  private:
  const ::KuplungApp::Vec3& _internal_ambientcolor() const;
  ::KuplungApp::Vec3* _internal_mutable_ambientcolor();

  public:
  // required .KuplungApp.Vec3 DiffuseColor = 4;
  bool has_diffusecolor() const;
  void clear_diffusecolor() ;
  const ::KuplungApp::Vec3& diffusecolor() const;
  PROTOBUF_NODISCARD ::KuplungApp::Vec3* release_diffusecolor();
  ::KuplungApp::Vec3* mutable_diffusecolor();
  void set_allocated_diffusecolor(::KuplungApp::Vec3* value);
  void unsafe_arena_set_allocated_diffusecolor(::KuplungApp::Vec3* value);
  ::KuplungApp::Vec3* unsafe_arena_release_diffusecolor();

  private:
  const ::KuplungApp::Vec3& _internal_diffusecolor() const;
  ::KuplungApp::Vec3* _internal_mutable_diffusecolor();

  public:
  // required .KuplungApp.Vec3 SpecularColor = 5;
  bool has_specularcolor() const;
  void clear_specularcolor() ;
  const ::KuplungApp::Vec3& specularcolor() const;
  PROTOBUF_NODISCARD ::KuplungApp::Vec3* release_specularcolor();
  ::KuplungApp::Vec3* mutable_specularcolor();
  void set_allocated_specularcolor(::KuplungApp::Vec3* value);
  void unsafe_arena_set_allocated_specularcolor(::KuplungApp::Vec3* value);
  ::KuplungApp::Vec3* unsafe_arena_release_specularcolor();

  private:
  const ::KuplungApp::Vec3& _internal_specularcolor() const;
  ::KuplungApp::Vec3* _internal_mutable_specularcolor();

  public:
  // required .KuplungApp.Vec3 EmissionColor = 6;
  bool has_emissioncolor() const;
  void clear_emissioncolor() ;
  const ::KuplungApp::Vec3& emissioncolor() const;
  PROTOBUF_NODISCARD ::KuplungApp::Vec3* release_emissioncolor();
  ::KuplungApp::Vec3* mutable_emissioncolor();
  void set_allocated_emissioncolor(::KuplungApp::Vec3* value);
  void unsafe_arena_set_allocated_emissioncolor(::KuplungApp::Vec3* value);
  ::KuplungApp::Vec3* unsafe_arena_release_emissioncolor();

  private:
  const ::KuplungApp::Vec3& _internal_emissioncolor() const;
  ::KuplungApp::Vec3* _internal_mutable_emissioncolor();

  public:
  // required .KuplungApp.MeshMaterialTextureImage TextureAmbient = 11;
  bool has_textureambient() const;
  void clear_textureambient() ;
  const ::KuplungApp::MeshMaterialTextureImage& textureambient() const;
  PROTOBUF_NODISCARD ::KuplungApp::MeshMaterialTextureImage* release_textureambient();
  ::KuplungApp::MeshMaterialTextureImage* mutable_textureambient();
  void set_allocated_textureambient(::KuplungApp::MeshMaterialTextureImage* value);
  void unsafe_arena_set_allocated_textureambient(::KuplungApp::MeshMaterialTextureImage* value);
  ::KuplungApp::MeshMaterialTextureImage* unsafe_arena_release_textureambient();

  private:
  const ::KuplungApp::MeshMaterialTextureImage& _internal_textureambient() const;
  ::KuplungApp::MeshMaterialTextureImage* _internal_mutable_textureambient();

  public:
  // required .KuplungApp.MeshMaterialTextureImage TextureDiffuse = 12;
  bool has_texturediffuse() const;
  void clear_texturediffuse() ;
  const ::KuplungApp::MeshMaterialTextureImage& texturediffuse() const;
  PROTOBUF_NODISCARD ::KuplungApp::MeshMaterialTextureImage* release_texturediffuse();
  ::KuplungApp::MeshMaterialTextureImage* mutable_texturediffuse();
  void set_allocated_texturediffuse(::KuplungApp::MeshMaterialTextureImage* value);
  void unsafe_arena_set_allocated_texturediffuse(::KuplungApp::MeshMaterialTextureImage* value);
  ::KuplungApp::MeshMaterialTextureImage* unsafe_arena_release_texturediffuse();

  private:
  const ::KuplungApp::MeshMaterialTextureImage& _internal_texturediffuse() const;
  ::KuplungApp::MeshMaterialTextureImage* _internal_mutable_texturediffuse();

  public:
  // required .KuplungApp.MeshMaterialTextureImage TextureSpecular = 13;
  bool has_texturespecular() const;
  void clear_texturespecular() ;
  const ::KuplungApp::MeshMaterialTextureImage& texturespecular() const;
  PROTOBUF_NODISCARD ::KuplungApp::MeshMaterialTextureImage* release_texturespecular();
  ::KuplungApp::MeshMaterialTextureImage* mutable_texturespecular();
  void set_allocated_texturespecular(::KuplungApp::MeshMaterialTextureImage* value);
  void unsafe_arena_set_allocated_texturespecular(::KuplungApp::MeshMaterialTextureImage* value);
  ::KuplungApp::MeshMaterialTextureImage* unsafe_arena_release_texturespecular();

  private:
  const ::KuplungApp::MeshMaterialTextureImage& _internal_texturespecular() const;
  ::KuplungApp::MeshMaterialTextureImage* _internal_mutable_texturespecular();

  public:
  // required .KuplungApp.MeshMaterialTextureImage TextureSpecularExp = 14;
  bool has_texturespecularexp() const;
  void clear_texturespecularexp() ;
  const ::KuplungApp::MeshMaterialTextureImage& texturespecularexp() const;
  PROTOBUF_NODISCARD ::KuplungApp::MeshMaterialTextureImage* release_texturespecularexp();
  ::KuplungApp::MeshMaterialTextureImage* mutable_texturespecularexp();
  void set_allocated_texturespecularexp(::KuplungApp::MeshMaterialTextureImage* value);
  void unsafe_arena_set_allocated_texturespecularexp(::KuplungApp::MeshMaterialTextureImage* value);
  ::KuplungApp::MeshMaterialTextureImage* unsafe_arena_release_texturespecularexp();

  private:
  const ::KuplungApp::MeshMaterialTextureImage& _internal_texturespecularexp() const;
  ::KuplungApp::MeshMaterialTextureImage* _internal_mutable_texturespecularexp();

  public:
  // required .KuplungApp.MeshMaterialTextureImage TextureDissolve = 15;
  bool has_texturedissolve() const;
  void clear_texturedissolve() ;
  const ::KuplungApp::MeshMaterialTextureImage& texturedissolve() const;
  PROTOBUF_NODISCARD ::KuplungApp::MeshMaterialTextureImage* release_texturedissolve();
  ::KuplungApp::MeshMaterialTextureImage* mutable_texturedissolve();
  void set_allocated_texturedissolve(::KuplungApp::MeshMaterialTextureImage* value);
  void unsafe_arena_set_allocated_texturedissolve(::KuplungApp::MeshMaterialTextureImage* value);
  ::KuplungApp::MeshMaterialTextureImage* unsafe_arena_release_texturedissolve();

  private:
  const ::KuplungApp::MeshMaterialTextureImage& _internal_texturedissolve() const;
  ::KuplungApp::MeshMaterialTextureImage* _internal_mutable_texturedissolve();

  public:
  // required .KuplungApp.MeshMaterialTextureImage TextureBump = 16;
  bool has_texturebump() const;
  void clear_texturebump() ;
  const ::KuplungApp::MeshMaterialTextureImage& texturebump() const;
  PROTOBUF_NODISCARD ::KuplungApp::MeshMaterialTextureImage* release_texturebump();
  ::KuplungApp::MeshMaterialTextureImage* mutable_texturebump();
  void set_allocated_texturebump(::KuplungApp::MeshMaterialTextureImage* value);
  void unsafe_arena_set_allocated_texturebump(::KuplungApp::MeshMaterialTextureImage* value);
  ::KuplungApp::MeshMaterialTextureImage* unsafe_arena_release_texturebump();

  private:
  const ::KuplungApp::MeshMaterialTextureImage& _internal_texturebump() const;
  ::KuplungApp::MeshMaterialTextureImage* _internal_mutable_texturebump();

  public:
  // required .KuplungApp.MeshMaterialTextureImage TextureDisplacement = 17;
  bool has_texturedisplacement() const;
  void clear_texturedisplacement() ;
  const ::KuplungApp::MeshMaterialTextureImage& texturedisplacement() const;
  PROTOBUF_NODISCARD ::KuplungApp::MeshMaterialTextureImage* release_texturedisplacement();
  ::KuplungApp::MeshMaterialTextureImage* mutable_texturedisplacement();
  void set_allocated_texturedisplacement(::KuplungApp::MeshMaterialTextureImage* value);
  void unsafe_arena_set_allocated_texturedisplacement(::KuplungApp::MeshMaterialTextureImage* value);
  ::KuplungApp::MeshMaterialTextureImage* unsafe_arena_release_texturedisplacement();

  private:
  const ::KuplungApp::MeshMaterialTextureImage& _internal_texturedisplacement() const;
  ::KuplungApp::MeshMaterialTextureImage* _internal_mutable_texturedisplacement();

  public:
  // required int32 MaterialID = 1;
  bool has_materialid() const;
  void clear_materialid() ;
  ::int32_t materialid() const;
  void set_materialid(::int32_t value);

  private:
  ::int32_t _internal_materialid() const;
  void _internal_set_materialid(::int32_t value);

  public:
  // required float SpecularExp = 7;
  bool has_specularexp() const;
  void clear_specularexp() ;
  float specularexp() const;
  void set_specularexp(float value);

  private:
  float _internal_specularexp() const;
  void _internal_set_specularexp(float value);

  public:
  // required float Transparency = 8;
  bool has_transparency() const;
  void clear_transparency() ;
  float transparency() const;
  void set_transparency(float value);

  private:
  float _internal_transparency() const;
  void _internal_set_transparency(float value);

  public:
  // required fixed32 IlluminationMode = 9;
  bool has_illuminationmode() const;
  void clear_illuminationmode() ;
  ::uint32_t illuminationmode() const;
  void set_illuminationmode(::uint32_t value);

  private:
  ::uint32_t _internal_illuminationmode() const;
  void _internal_set_illuminationmode(::uint32_t value);

  public:
  // required float OpticalDensity = 10;
  bool has_opticaldensity() const;
  void clear_opticaldensity() ;
  float opticaldensity() const;
  void set_opticaldensity(float value);

  private:
  float _internal_opticaldensity() const;
  void _internal_set_opticaldensity(float value);

  public:
  // @@protoc_insertion_point(class_scope:KuplungApp.MeshModelMaterial)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 17, 11,
      66, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr materialtitle_;
    ::KuplungApp::Vec3* ambientcolor_;
    ::KuplungApp::Vec3* diffusecolor_;
    ::KuplungApp::Vec3* specularcolor_;
    ::KuplungApp::Vec3* emissioncolor_;
    ::KuplungApp::MeshMaterialTextureImage* textureambient_;
    ::KuplungApp::MeshMaterialTextureImage* texturediffuse_;
    ::KuplungApp::MeshMaterialTextureImage* texturespecular_;
    ::KuplungApp::MeshMaterialTextureImage* texturespecularexp_;
    ::KuplungApp::MeshMaterialTextureImage* texturedissolve_;
    ::KuplungApp::MeshMaterialTextureImage* texturebump_;
    ::KuplungApp::MeshMaterialTextureImage* texturedisplacement_;
    ::int32_t materialid_;
    float specularexp_;
    float transparency_;
    ::uint32_t illuminationmode_;
    float opticaldensity_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KuplungDefinitions_2eproto;
};// -------------------------------------------------------------------

class MaterialColor final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KuplungApp.MaterialColor) */ {
 public:
  inline MaterialColor() : MaterialColor(nullptr) {}
  ~MaterialColor() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MaterialColor(::google::protobuf::internal::ConstantInitialized);

  inline MaterialColor(const MaterialColor& from)
      : MaterialColor(nullptr, from) {}
  MaterialColor(MaterialColor&& from) noexcept
    : MaterialColor() {
    *this = ::std::move(from);
  }

  inline MaterialColor& operator=(const MaterialColor& from) {
    CopyFrom(from);
    return *this;
  }
  inline MaterialColor& operator=(MaterialColor&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MaterialColor& default_instance() {
    return *internal_default_instance();
  }
  static inline const MaterialColor* internal_default_instance() {
    return reinterpret_cast<const MaterialColor*>(
               &_MaterialColor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MaterialColor& a, MaterialColor& b) {
    a.Swap(&b);
  }
  inline void Swap(MaterialColor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MaterialColor* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MaterialColor* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MaterialColor>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MaterialColor& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MaterialColor& from) {
    MaterialColor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MaterialColor* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "KuplungApp.MaterialColor";
  }
  protected:
  explicit MaterialColor(::google::protobuf::Arena* arena);
  MaterialColor(::google::protobuf::Arena* arena, const MaterialColor& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 4,
    kColorPickerOpenFieldNumber = 1,
    kAnimateFieldNumber = 2,
    kStrengthFieldNumber = 3,
  };
  // required .KuplungApp.Vec3 color = 4;
  bool has_color() const;
  void clear_color() ;
  const ::KuplungApp::Vec3& color() const;
  PROTOBUF_NODISCARD ::KuplungApp::Vec3* release_color();
  ::KuplungApp::Vec3* mutable_color();
  void set_allocated_color(::KuplungApp::Vec3* value);
  void unsafe_arena_set_allocated_color(::KuplungApp::Vec3* value);
  ::KuplungApp::Vec3* unsafe_arena_release_color();

  private:
  const ::KuplungApp::Vec3& _internal_color() const;
  ::KuplungApp::Vec3* _internal_mutable_color();

  public:
  // required bool colorPickerOpen = 1;
  bool has_colorpickeropen() const;
  void clear_colorpickeropen() ;
  bool colorpickeropen() const;
  void set_colorpickeropen(bool value);

  private:
  bool _internal_colorpickeropen() const;
  void _internal_set_colorpickeropen(bool value);

  public:
  // required bool animate = 2;
  bool has_animate() const;
  void clear_animate() ;
  bool animate() const;
  void set_animate(bool value);

  private:
  bool _internal_animate() const;
  void _internal_set_animate(bool value);

  public:
  // required float strength = 3;
  bool has_strength() const;
  void clear_strength() ;
  float strength() const;
  void set_strength(float value);

  private:
  float _internal_strength() const;
  void _internal_set_strength(float value);

  public:
  // @@protoc_insertion_point(class_scope:KuplungApp.MaterialColor)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::KuplungApp::Vec3* color_;
    bool colorpickeropen_;
    bool animate_;
    float strength_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KuplungDefinitions_2eproto;
};// -------------------------------------------------------------------

class Mesh final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KuplungApp.Mesh) */ {
 public:
  inline Mesh() : Mesh(nullptr) {}
  ~Mesh() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Mesh(::google::protobuf::internal::ConstantInitialized);

  inline Mesh(const Mesh& from)
      : Mesh(nullptr, from) {}
  Mesh(Mesh&& from) noexcept
    : Mesh() {
    *this = ::std::move(from);
  }

  inline Mesh& operator=(const Mesh& from) {
    CopyFrom(from);
    return *this;
  }
  inline Mesh& operator=(Mesh&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Mesh& default_instance() {
    return *internal_default_instance();
  }
  static inline const Mesh* internal_default_instance() {
    return reinterpret_cast<const Mesh*>(
               &_Mesh_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Mesh& a, Mesh& b) {
    a.Swap(&b);
  }
  inline void Swap(Mesh* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Mesh* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Mesh* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Mesh>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Mesh& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Mesh& from) {
    Mesh::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Mesh* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "KuplungApp.Mesh";
  }
  protected:
  explicit Mesh(::google::protobuf::Arena* arena);
  Mesh(::google::protobuf::Arena* arena, const Mesh& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVerticesFieldNumber = 10,
    kTextureCoordinatesFieldNumber = 11,
    kNormalsFieldNumber = 12,
    kIndicesFieldNumber = 13,
    kModelTitleFieldNumber = 3,
    kMaterialTitleFieldNumber = 4,
    kFileFieldNumber = 2,
    kModelMaterialFieldNumber = 9,
    kIDFieldNumber = 1,
    kCountVerticesFieldNumber = 5,
    kCountTextureCoordinatesFieldNumber = 6,
    kCountNormalsFieldNumber = 7,
    kCountIndicesFieldNumber = 8,
  };
  // repeated .KuplungApp.Vec3 vertices = 10;
  int vertices_size() const;
  private:
  int _internal_vertices_size() const;

  public:
  void clear_vertices() ;
  ::KuplungApp::Vec3* mutable_vertices(int index);
  ::google::protobuf::RepeatedPtrField< ::KuplungApp::Vec3 >*
      mutable_vertices();
  private:
  const ::google::protobuf::RepeatedPtrField<::KuplungApp::Vec3>& _internal_vertices() const;
  ::google::protobuf::RepeatedPtrField<::KuplungApp::Vec3>* _internal_mutable_vertices();
  public:
  const ::KuplungApp::Vec3& vertices(int index) const;
  ::KuplungApp::Vec3* add_vertices();
  const ::google::protobuf::RepeatedPtrField< ::KuplungApp::Vec3 >&
      vertices() const;
  // repeated .KuplungApp.Vec2 texture_coordinates = 11;
  int texture_coordinates_size() const;
  private:
  int _internal_texture_coordinates_size() const;

  public:
  void clear_texture_coordinates() ;
  ::KuplungApp::Vec2* mutable_texture_coordinates(int index);
  ::google::protobuf::RepeatedPtrField< ::KuplungApp::Vec2 >*
      mutable_texture_coordinates();
  private:
  const ::google::protobuf::RepeatedPtrField<::KuplungApp::Vec2>& _internal_texture_coordinates() const;
  ::google::protobuf::RepeatedPtrField<::KuplungApp::Vec2>* _internal_mutable_texture_coordinates();
  public:
  const ::KuplungApp::Vec2& texture_coordinates(int index) const;
  ::KuplungApp::Vec2* add_texture_coordinates();
  const ::google::protobuf::RepeatedPtrField< ::KuplungApp::Vec2 >&
      texture_coordinates() const;
  // repeated .KuplungApp.Vec3 normals = 12;
  int normals_size() const;
  private:
  int _internal_normals_size() const;

  public:
  void clear_normals() ;
  ::KuplungApp::Vec3* mutable_normals(int index);
  ::google::protobuf::RepeatedPtrField< ::KuplungApp::Vec3 >*
      mutable_normals();
  private:
  const ::google::protobuf::RepeatedPtrField<::KuplungApp::Vec3>& _internal_normals() const;
  ::google::protobuf::RepeatedPtrField<::KuplungApp::Vec3>* _internal_mutable_normals();
  public:
  const ::KuplungApp::Vec3& normals(int index) const;
  ::KuplungApp::Vec3* add_normals();
  const ::google::protobuf::RepeatedPtrField< ::KuplungApp::Vec3 >&
      normals() const;
  // repeated fixed32 indices = 13;
  int indices_size() const;
  private:
  int _internal_indices_size() const;

  public:
  void clear_indices() ;
  ::uint32_t indices(int index) const;
  void set_indices(int index, ::uint32_t value);
  void add_indices(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& indices() const;
  ::google::protobuf::RepeatedField<::uint32_t>* mutable_indices();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_indices() const;
  ::google::protobuf::RepeatedField<::uint32_t>* _internal_mutable_indices();

  public:
  // required string ModelTitle = 3;
  bool has_modeltitle() const;
  void clear_modeltitle() ;
  const std::string& modeltitle() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_modeltitle(Arg_&& arg, Args_... args);
  std::string* mutable_modeltitle();
  PROTOBUF_NODISCARD std::string* release_modeltitle();
  void set_allocated_modeltitle(std::string* value);

  private:
  const std::string& _internal_modeltitle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modeltitle(
      const std::string& value);
  std::string* _internal_mutable_modeltitle();

  public:
  // required string MaterialTitle = 4;
  bool has_materialtitle() const;
  void clear_materialtitle() ;
  const std::string& materialtitle() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_materialtitle(Arg_&& arg, Args_... args);
  std::string* mutable_materialtitle();
  PROTOBUF_NODISCARD std::string* release_materialtitle();
  void set_allocated_materialtitle(std::string* value);

  private:
  const std::string& _internal_materialtitle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_materialtitle(
      const std::string& value);
  std::string* _internal_mutable_materialtitle();

  public:
  // required .KuplungApp.FBEntity File = 2;
  bool has_file() const;
  void clear_file() ;
  const ::KuplungApp::FBEntity& file() const;
  PROTOBUF_NODISCARD ::KuplungApp::FBEntity* release_file();
  ::KuplungApp::FBEntity* mutable_file();
  void set_allocated_file(::KuplungApp::FBEntity* value);
  void unsafe_arena_set_allocated_file(::KuplungApp::FBEntity* value);
  ::KuplungApp::FBEntity* unsafe_arena_release_file();

  private:
  const ::KuplungApp::FBEntity& _internal_file() const;
  ::KuplungApp::FBEntity* _internal_mutable_file();

  public:
  // required .KuplungApp.MeshModelMaterial ModelMaterial = 9;
  bool has_modelmaterial() const;
  void clear_modelmaterial() ;
  const ::KuplungApp::MeshModelMaterial& modelmaterial() const;
  PROTOBUF_NODISCARD ::KuplungApp::MeshModelMaterial* release_modelmaterial();
  ::KuplungApp::MeshModelMaterial* mutable_modelmaterial();
  void set_allocated_modelmaterial(::KuplungApp::MeshModelMaterial* value);
  void unsafe_arena_set_allocated_modelmaterial(::KuplungApp::MeshModelMaterial* value);
  ::KuplungApp::MeshModelMaterial* unsafe_arena_release_modelmaterial();

  private:
  const ::KuplungApp::MeshModelMaterial& _internal_modelmaterial() const;
  ::KuplungApp::MeshModelMaterial* _internal_mutable_modelmaterial();

  public:
  // required int32 ID = 1;
  bool has_id() const;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // required int32 countVertices = 5;
  bool has_countvertices() const;
  void clear_countvertices() ;
  ::int32_t countvertices() const;
  void set_countvertices(::int32_t value);

  private:
  ::int32_t _internal_countvertices() const;
  void _internal_set_countvertices(::int32_t value);

  public:
  // required int32 countTextureCoordinates = 6;
  bool has_counttexturecoordinates() const;
  void clear_counttexturecoordinates() ;
  ::int32_t counttexturecoordinates() const;
  void set_counttexturecoordinates(::int32_t value);

  private:
  ::int32_t _internal_counttexturecoordinates() const;
  void _internal_set_counttexturecoordinates(::int32_t value);

  public:
  // required int32 countNormals = 7;
  bool has_countnormals() const;
  void clear_countnormals() ;
  ::int32_t countnormals() const;
  void set_countnormals(::int32_t value);

  private:
  ::int32_t _internal_countnormals() const;
  void _internal_set_countnormals(::int32_t value);

  public:
  // required int32 countIndices = 8;
  bool has_countindices() const;
  void clear_countindices() ;
  ::int32_t countindices() const;
  void set_countindices(::int32_t value);

  private:
  ::int32_t _internal_countindices() const;
  void _internal_set_countindices(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:KuplungApp.Mesh)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 13, 5,
      55, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::KuplungApp::Vec3 > vertices_;
    ::google::protobuf::RepeatedPtrField< ::KuplungApp::Vec2 > texture_coordinates_;
    ::google::protobuf::RepeatedPtrField< ::KuplungApp::Vec3 > normals_;
    ::google::protobuf::RepeatedField<::uint32_t> indices_;
    ::google::protobuf::internal::ArenaStringPtr modeltitle_;
    ::google::protobuf::internal::ArenaStringPtr materialtitle_;
    ::KuplungApp::FBEntity* file_;
    ::KuplungApp::MeshModelMaterial* modelmaterial_;
    ::int32_t id_;
    ::int32_t countvertices_;
    ::int32_t counttexturecoordinates_;
    ::int32_t countnormals_;
    ::int32_t countindices_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KuplungDefinitions_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Vec2

// required float x = 1;
inline bool Vec2::has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Vec2::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float Vec2::x() const {
  // @@protoc_insertion_point(field_get:KuplungApp.Vec2.x)
  return _internal_x();
}
inline void Vec2::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:KuplungApp.Vec2.x)
}
inline float Vec2::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void Vec2::_internal_set_x(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.x_ = value;
}

// required float y = 2;
inline bool Vec2::has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Vec2::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Vec2::y() const {
  // @@protoc_insertion_point(field_get:KuplungApp.Vec2.y)
  return _internal_y();
}
inline void Vec2::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:KuplungApp.Vec2.y)
}
inline float Vec2::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void Vec2::_internal_set_y(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.y_ = value;
}

// -------------------------------------------------------------------

// Vec3

// required float x = 1;
inline bool Vec3::has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Vec3::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float Vec3::x() const {
  // @@protoc_insertion_point(field_get:KuplungApp.Vec3.x)
  return _internal_x();
}
inline void Vec3::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:KuplungApp.Vec3.x)
}
inline float Vec3::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void Vec3::_internal_set_x(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.x_ = value;
}

// required float y = 2;
inline bool Vec3::has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Vec3::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Vec3::y() const {
  // @@protoc_insertion_point(field_get:KuplungApp.Vec3.y)
  return _internal_y();
}
inline void Vec3::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:KuplungApp.Vec3.y)
}
inline float Vec3::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void Vec3::_internal_set_y(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.y_ = value;
}

// required float z = 3;
inline bool Vec3::has_z() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Vec3::clear_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.z_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float Vec3::z() const {
  // @@protoc_insertion_point(field_get:KuplungApp.Vec3.z)
  return _internal_z();
}
inline void Vec3::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:KuplungApp.Vec3.z)
}
inline float Vec3::_internal_z() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.z_;
}
inline void Vec3::_internal_set_z(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// Vec4

// required float x = 1;
inline bool Vec4::has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Vec4::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float Vec4::x() const {
  // @@protoc_insertion_point(field_get:KuplungApp.Vec4.x)
  return _internal_x();
}
inline void Vec4::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:KuplungApp.Vec4.x)
}
inline float Vec4::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void Vec4::_internal_set_x(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.x_ = value;
}

// required float y = 2;
inline bool Vec4::has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Vec4::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Vec4::y() const {
  // @@protoc_insertion_point(field_get:KuplungApp.Vec4.y)
  return _internal_y();
}
inline void Vec4::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:KuplungApp.Vec4.y)
}
inline float Vec4::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void Vec4::_internal_set_y(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.y_ = value;
}

// required float z = 3;
inline bool Vec4::has_z() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Vec4::clear_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.z_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float Vec4::z() const {
  // @@protoc_insertion_point(field_get:KuplungApp.Vec4.z)
  return _internal_z();
}
inline void Vec4::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:KuplungApp.Vec4.z)
}
inline float Vec4::_internal_z() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.z_;
}
inline void Vec4::_internal_set_z(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.z_ = value;
}

// required float w = 4;
inline bool Vec4::has_w() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void Vec4::clear_w() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.w_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float Vec4::w() const {
  // @@protoc_insertion_point(field_get:KuplungApp.Vec4.w)
  return _internal_w();
}
inline void Vec4::set_w(float value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:KuplungApp.Vec4.w)
}
inline float Vec4::_internal_w() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.w_;
}
inline void Vec4::_internal_set_w(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.w_ = value;
}

// -------------------------------------------------------------------

// ObjectCoordinate

// required bool animate = 1;
inline bool ObjectCoordinate::has_animate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ObjectCoordinate::clear_animate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.animate_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool ObjectCoordinate::animate() const {
  // @@protoc_insertion_point(field_get:KuplungApp.ObjectCoordinate.animate)
  return _internal_animate();
}
inline void ObjectCoordinate::set_animate(bool value) {
  _internal_set_animate(value);
  // @@protoc_insertion_point(field_set:KuplungApp.ObjectCoordinate.animate)
}
inline bool ObjectCoordinate::_internal_animate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.animate_;
}
inline void ObjectCoordinate::_internal_set_animate(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.animate_ = value;
}

// required float point = 2;
inline bool ObjectCoordinate::has_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ObjectCoordinate::clear_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.point_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float ObjectCoordinate::point() const {
  // @@protoc_insertion_point(field_get:KuplungApp.ObjectCoordinate.point)
  return _internal_point();
}
inline void ObjectCoordinate::set_point(float value) {
  _internal_set_point(value);
  // @@protoc_insertion_point(field_set:KuplungApp.ObjectCoordinate.point)
}
inline float ObjectCoordinate::_internal_point() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.point_;
}
inline void ObjectCoordinate::_internal_set_point(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.point_ = value;
}

// -------------------------------------------------------------------

// FBEntity

// required bool isFile = 1;
inline bool FBEntity::has_isfile() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void FBEntity::clear_isfile() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.isfile_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool FBEntity::isfile() const {
  // @@protoc_insertion_point(field_get:KuplungApp.FBEntity.isFile)
  return _internal_isfile();
}
inline void FBEntity::set_isfile(bool value) {
  _internal_set_isfile(value);
  // @@protoc_insertion_point(field_set:KuplungApp.FBEntity.isFile)
}
inline bool FBEntity::_internal_isfile() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.isfile_;
}
inline void FBEntity::_internal_set_isfile(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.isfile_ = value;
}

// required string path = 2;
inline bool FBEntity::has_path() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void FBEntity::clear_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.path_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FBEntity::path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:KuplungApp.FBEntity.path)
  return _internal_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FBEntity::set_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:KuplungApp.FBEntity.path)
}
inline std::string* FBEntity::mutable_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:KuplungApp.FBEntity.path)
  return _s;
}
inline const std::string& FBEntity::_internal_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.path_.Get();
}
inline void FBEntity::_internal_set_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.path_.Set(value, GetArena());
}
inline std::string* FBEntity::_internal_mutable_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.path_.Mutable( GetArena());
}
inline std::string* FBEntity::release_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:KuplungApp.FBEntity.path)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.path_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.path_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void FBEntity::set_allocated_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.path_.IsDefault()) {
          _impl_.path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KuplungApp.FBEntity.path)
}

// required string title = 3;
inline bool FBEntity::has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void FBEntity::clear_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& FBEntity::title() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:KuplungApp.FBEntity.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FBEntity::set_title(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:KuplungApp.FBEntity.title)
}
inline std::string* FBEntity::mutable_title() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:KuplungApp.FBEntity.title)
  return _s;
}
inline const std::string& FBEntity::_internal_title() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.title_.Get();
}
inline void FBEntity::_internal_set_title(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.title_.Set(value, GetArena());
}
inline std::string* FBEntity::_internal_mutable_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.title_.Mutable( GetArena());
}
inline std::string* FBEntity::release_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:KuplungApp.FBEntity.title)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.title_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.title_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void FBEntity::set_allocated_title(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.title_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KuplungApp.FBEntity.title)
}

// required string extension = 4;
inline bool FBEntity::has_extension() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void FBEntity::clear_extension() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.extension_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& FBEntity::extension() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:KuplungApp.FBEntity.extension)
  return _internal_extension();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FBEntity::set_extension(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.extension_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:KuplungApp.FBEntity.extension)
}
inline std::string* FBEntity::mutable_extension() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_extension();
  // @@protoc_insertion_point(field_mutable:KuplungApp.FBEntity.extension)
  return _s;
}
inline const std::string& FBEntity::_internal_extension() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.extension_.Get();
}
inline void FBEntity::_internal_set_extension(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.extension_.Set(value, GetArena());
}
inline std::string* FBEntity::_internal_mutable_extension() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.extension_.Mutable( GetArena());
}
inline std::string* FBEntity::release_extension() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:KuplungApp.FBEntity.extension)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.extension_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.extension_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void FBEntity::set_allocated_extension(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.extension_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.extension_.IsDefault()) {
          _impl_.extension_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KuplungApp.FBEntity.extension)
}

// required string modifiedDate = 5;
inline bool FBEntity::has_modifieddate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void FBEntity::clear_modifieddate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.modifieddate_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& FBEntity::modifieddate() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:KuplungApp.FBEntity.modifiedDate)
  return _internal_modifieddate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FBEntity::set_modifieddate(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.modifieddate_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:KuplungApp.FBEntity.modifiedDate)
}
inline std::string* FBEntity::mutable_modifieddate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_modifieddate();
  // @@protoc_insertion_point(field_mutable:KuplungApp.FBEntity.modifiedDate)
  return _s;
}
inline const std::string& FBEntity::_internal_modifieddate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.modifieddate_.Get();
}
inline void FBEntity::_internal_set_modifieddate(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.modifieddate_.Set(value, GetArena());
}
inline std::string* FBEntity::_internal_mutable_modifieddate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.modifieddate_.Mutable( GetArena());
}
inline std::string* FBEntity::release_modifieddate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:KuplungApp.FBEntity.modifiedDate)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.modifieddate_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.modifieddate_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void FBEntity::set_allocated_modifieddate(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.modifieddate_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.modifieddate_.IsDefault()) {
          _impl_.modifieddate_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KuplungApp.FBEntity.modifiedDate)
}

// required string size = 6;
inline bool FBEntity::has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void FBEntity::clear_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.size_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& FBEntity::size() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:KuplungApp.FBEntity.size)
  return _internal_size();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FBEntity::set_size(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.size_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:KuplungApp.FBEntity.size)
}
inline std::string* FBEntity::mutable_size() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_size();
  // @@protoc_insertion_point(field_mutable:KuplungApp.FBEntity.size)
  return _s;
}
inline const std::string& FBEntity::_internal_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.size_.Get();
}
inline void FBEntity::_internal_set_size(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.size_.Set(value, GetArena());
}
inline std::string* FBEntity::_internal_mutable_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.size_.Mutable( GetArena());
}
inline std::string* FBEntity::release_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:KuplungApp.FBEntity.size)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.size_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.size_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void FBEntity::set_allocated_size(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.size_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.size_.IsDefault()) {
          _impl_.size_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KuplungApp.FBEntity.size)
}

// -------------------------------------------------------------------

// MaterialColor

// required bool colorPickerOpen = 1;
inline bool MaterialColor::has_colorpickeropen() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MaterialColor::clear_colorpickeropen() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.colorpickeropen_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool MaterialColor::colorpickeropen() const {
  // @@protoc_insertion_point(field_get:KuplungApp.MaterialColor.colorPickerOpen)
  return _internal_colorpickeropen();
}
inline void MaterialColor::set_colorpickeropen(bool value) {
  _internal_set_colorpickeropen(value);
  // @@protoc_insertion_point(field_set:KuplungApp.MaterialColor.colorPickerOpen)
}
inline bool MaterialColor::_internal_colorpickeropen() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.colorpickeropen_;
}
inline void MaterialColor::_internal_set_colorpickeropen(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.colorpickeropen_ = value;
}

// required bool animate = 2;
inline bool MaterialColor::has_animate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void MaterialColor::clear_animate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.animate_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool MaterialColor::animate() const {
  // @@protoc_insertion_point(field_get:KuplungApp.MaterialColor.animate)
  return _internal_animate();
}
inline void MaterialColor::set_animate(bool value) {
  _internal_set_animate(value);
  // @@protoc_insertion_point(field_set:KuplungApp.MaterialColor.animate)
}
inline bool MaterialColor::_internal_animate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.animate_;
}
inline void MaterialColor::_internal_set_animate(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.animate_ = value;
}

// required float strength = 3;
inline bool MaterialColor::has_strength() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void MaterialColor::clear_strength() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.strength_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float MaterialColor::strength() const {
  // @@protoc_insertion_point(field_get:KuplungApp.MaterialColor.strength)
  return _internal_strength();
}
inline void MaterialColor::set_strength(float value) {
  _internal_set_strength(value);
  // @@protoc_insertion_point(field_set:KuplungApp.MaterialColor.strength)
}
inline float MaterialColor::_internal_strength() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.strength_;
}
inline void MaterialColor::_internal_set_strength(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.strength_ = value;
}

// required .KuplungApp.Vec3 color = 4;
inline bool MaterialColor::has_color() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.color_ != nullptr);
  return value;
}
inline void MaterialColor::clear_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.color_ != nullptr) _impl_.color_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::KuplungApp::Vec3& MaterialColor::_internal_color() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::KuplungApp::Vec3* p = _impl_.color_;
  return p != nullptr ? *p : reinterpret_cast<const ::KuplungApp::Vec3&>(::KuplungApp::_Vec3_default_instance_);
}
inline const ::KuplungApp::Vec3& MaterialColor::color() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:KuplungApp.MaterialColor.color)
  return _internal_color();
}
inline void MaterialColor::unsafe_arena_set_allocated_color(::KuplungApp::Vec3* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.color_);
  }
  _impl_.color_ = reinterpret_cast<::KuplungApp::Vec3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KuplungApp.MaterialColor.color)
}
inline ::KuplungApp::Vec3* MaterialColor::release_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::KuplungApp::Vec3* released = _impl_.color_;
  _impl_.color_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::KuplungApp::Vec3* MaterialColor::unsafe_arena_release_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:KuplungApp.MaterialColor.color)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::KuplungApp::Vec3* temp = _impl_.color_;
  _impl_.color_ = nullptr;
  return temp;
}
inline ::KuplungApp::Vec3* MaterialColor::_internal_mutable_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.color_ == nullptr) {
    auto* p = CreateMaybeMessage<::KuplungApp::Vec3>(GetArena());
    _impl_.color_ = reinterpret_cast<::KuplungApp::Vec3*>(p);
  }
  return _impl_.color_;
}
inline ::KuplungApp::Vec3* MaterialColor::mutable_color() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::KuplungApp::Vec3* _msg = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:KuplungApp.MaterialColor.color)
  return _msg;
}
inline void MaterialColor::set_allocated_color(::KuplungApp::Vec3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::KuplungApp::Vec3*>(_impl_.color_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::KuplungApp::Vec3*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.color_ = reinterpret_cast<::KuplungApp::Vec3*>(value);
  // @@protoc_insertion_point(field_set_allocated:KuplungApp.MaterialColor.color)
}

// -------------------------------------------------------------------

// MeshMaterialTextureImage

// required string Filename = 1;
inline bool MeshMaterialTextureImage::has_filename() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MeshMaterialTextureImage::clear_filename() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.filename_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MeshMaterialTextureImage::filename() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:KuplungApp.MeshMaterialTextureImage.Filename)
  return _internal_filename();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MeshMaterialTextureImage::set_filename(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.filename_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:KuplungApp.MeshMaterialTextureImage.Filename)
}
inline std::string* MeshMaterialTextureImage::mutable_filename() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:KuplungApp.MeshMaterialTextureImage.Filename)
  return _s;
}
inline const std::string& MeshMaterialTextureImage::_internal_filename() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.filename_.Get();
}
inline void MeshMaterialTextureImage::_internal_set_filename(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.filename_.Set(value, GetArena());
}
inline std::string* MeshMaterialTextureImage::_internal_mutable_filename() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.filename_.Mutable( GetArena());
}
inline std::string* MeshMaterialTextureImage::release_filename() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:KuplungApp.MeshMaterialTextureImage.Filename)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.filename_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.filename_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MeshMaterialTextureImage::set_allocated_filename(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.filename_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.filename_.IsDefault()) {
          _impl_.filename_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KuplungApp.MeshMaterialTextureImage.Filename)
}

// required string Image = 2;
inline bool MeshMaterialTextureImage::has_image() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MeshMaterialTextureImage::clear_image() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.image_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MeshMaterialTextureImage::image() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:KuplungApp.MeshMaterialTextureImage.Image)
  return _internal_image();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MeshMaterialTextureImage::set_image(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.image_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:KuplungApp.MeshMaterialTextureImage.Image)
}
inline std::string* MeshMaterialTextureImage::mutable_image() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:KuplungApp.MeshMaterialTextureImage.Image)
  return _s;
}
inline const std::string& MeshMaterialTextureImage::_internal_image() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.image_.Get();
}
inline void MeshMaterialTextureImage::_internal_set_image(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.image_.Set(value, GetArena());
}
inline std::string* MeshMaterialTextureImage::_internal_mutable_image() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.image_.Mutable( GetArena());
}
inline std::string* MeshMaterialTextureImage::release_image() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:KuplungApp.MeshMaterialTextureImage.Image)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.image_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.image_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MeshMaterialTextureImage::set_allocated_image(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.image_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.image_.IsDefault()) {
          _impl_.image_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KuplungApp.MeshMaterialTextureImage.Image)
}

// required int32 Width = 3;
inline bool MeshMaterialTextureImage::has_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void MeshMaterialTextureImage::clear_width() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.width_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t MeshMaterialTextureImage::width() const {
  // @@protoc_insertion_point(field_get:KuplungApp.MeshMaterialTextureImage.Width)
  return _internal_width();
}
inline void MeshMaterialTextureImage::set_width(::int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:KuplungApp.MeshMaterialTextureImage.Width)
}
inline ::int32_t MeshMaterialTextureImage::_internal_width() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.width_;
}
inline void MeshMaterialTextureImage::_internal_set_width(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.width_ = value;
}

// required int32 Height = 4;
inline bool MeshMaterialTextureImage::has_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void MeshMaterialTextureImage::clear_height() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.height_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t MeshMaterialTextureImage::height() const {
  // @@protoc_insertion_point(field_get:KuplungApp.MeshMaterialTextureImage.Height)
  return _internal_height();
}
inline void MeshMaterialTextureImage::set_height(::int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:KuplungApp.MeshMaterialTextureImage.Height)
}
inline ::int32_t MeshMaterialTextureImage::_internal_height() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.height_;
}
inline void MeshMaterialTextureImage::_internal_set_height(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.height_ = value;
}

// required bool UseTexture = 5;
inline bool MeshMaterialTextureImage::has_usetexture() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void MeshMaterialTextureImage::clear_usetexture() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.usetexture_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool MeshMaterialTextureImage::usetexture() const {
  // @@protoc_insertion_point(field_get:KuplungApp.MeshMaterialTextureImage.UseTexture)
  return _internal_usetexture();
}
inline void MeshMaterialTextureImage::set_usetexture(bool value) {
  _internal_set_usetexture(value);
  // @@protoc_insertion_point(field_set:KuplungApp.MeshMaterialTextureImage.UseTexture)
}
inline bool MeshMaterialTextureImage::_internal_usetexture() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.usetexture_;
}
inline void MeshMaterialTextureImage::_internal_set_usetexture(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.usetexture_ = value;
}

// repeated string Commands = 6;
inline int MeshMaterialTextureImage::_internal_commands_size() const {
  return _internal_commands().size();
}
inline int MeshMaterialTextureImage::commands_size() const {
  return _internal_commands_size();
}
inline void MeshMaterialTextureImage::clear_commands() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.commands_.Clear();
}
inline std::string* MeshMaterialTextureImage::add_commands()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_commands()->Add();
  // @@protoc_insertion_point(field_add_mutable:KuplungApp.MeshMaterialTextureImage.Commands)
  return _s;
}
inline const std::string& MeshMaterialTextureImage::commands(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:KuplungApp.MeshMaterialTextureImage.Commands)
  return _internal_commands().Get(index);
}
inline std::string* MeshMaterialTextureImage::mutable_commands(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:KuplungApp.MeshMaterialTextureImage.Commands)
  return _internal_mutable_commands()->Mutable(index);
}
inline void MeshMaterialTextureImage::set_commands(int index, const std::string& value) {
  _internal_mutable_commands()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:KuplungApp.MeshMaterialTextureImage.Commands)
}
inline void MeshMaterialTextureImage::set_commands(int index, std::string&& value) {
  _internal_mutable_commands()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:KuplungApp.MeshMaterialTextureImage.Commands)
}
inline void MeshMaterialTextureImage::set_commands(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_commands()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:KuplungApp.MeshMaterialTextureImage.Commands)
}
inline void MeshMaterialTextureImage::set_commands(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_commands()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KuplungApp.MeshMaterialTextureImage.Commands)
}
inline void MeshMaterialTextureImage::set_commands(int index, absl::string_view value) {
  _internal_mutable_commands()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:KuplungApp.MeshMaterialTextureImage.Commands)
}
inline void MeshMaterialTextureImage::add_commands(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_commands()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:KuplungApp.MeshMaterialTextureImage.Commands)
}
inline void MeshMaterialTextureImage::add_commands(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_commands()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:KuplungApp.MeshMaterialTextureImage.Commands)
}
inline void MeshMaterialTextureImage::add_commands(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_commands()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:KuplungApp.MeshMaterialTextureImage.Commands)
}
inline void MeshMaterialTextureImage::add_commands(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_commands()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:KuplungApp.MeshMaterialTextureImage.Commands)
}
inline void MeshMaterialTextureImage::add_commands(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_commands()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:KuplungApp.MeshMaterialTextureImage.Commands)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
MeshMaterialTextureImage::commands() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:KuplungApp.MeshMaterialTextureImage.Commands)
  return _internal_commands();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
MeshMaterialTextureImage::mutable_commands() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:KuplungApp.MeshMaterialTextureImage.Commands)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_commands();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
MeshMaterialTextureImage::_internal_commands() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.commands_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
MeshMaterialTextureImage::_internal_mutable_commands() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.commands_;
}

// -------------------------------------------------------------------

// MeshModelMaterial

// required int32 MaterialID = 1;
inline bool MeshModelMaterial::has_materialid() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void MeshModelMaterial::clear_materialid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.materialid_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline ::int32_t MeshModelMaterial::materialid() const {
  // @@protoc_insertion_point(field_get:KuplungApp.MeshModelMaterial.MaterialID)
  return _internal_materialid();
}
inline void MeshModelMaterial::set_materialid(::int32_t value) {
  _internal_set_materialid(value);
  // @@protoc_insertion_point(field_set:KuplungApp.MeshModelMaterial.MaterialID)
}
inline ::int32_t MeshModelMaterial::_internal_materialid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.materialid_;
}
inline void MeshModelMaterial::_internal_set_materialid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.materialid_ = value;
}

// required string MaterialTitle = 2;
inline bool MeshModelMaterial::has_materialtitle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MeshModelMaterial::clear_materialtitle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.materialtitle_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MeshModelMaterial::materialtitle() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:KuplungApp.MeshModelMaterial.MaterialTitle)
  return _internal_materialtitle();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MeshModelMaterial::set_materialtitle(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.materialtitle_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:KuplungApp.MeshModelMaterial.MaterialTitle)
}
inline std::string* MeshModelMaterial::mutable_materialtitle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_materialtitle();
  // @@protoc_insertion_point(field_mutable:KuplungApp.MeshModelMaterial.MaterialTitle)
  return _s;
}
inline const std::string& MeshModelMaterial::_internal_materialtitle() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.materialtitle_.Get();
}
inline void MeshModelMaterial::_internal_set_materialtitle(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.materialtitle_.Set(value, GetArena());
}
inline std::string* MeshModelMaterial::_internal_mutable_materialtitle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.materialtitle_.Mutable( GetArena());
}
inline std::string* MeshModelMaterial::release_materialtitle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:KuplungApp.MeshModelMaterial.MaterialTitle)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.materialtitle_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.materialtitle_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MeshModelMaterial::set_allocated_materialtitle(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.materialtitle_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.materialtitle_.IsDefault()) {
          _impl_.materialtitle_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KuplungApp.MeshModelMaterial.MaterialTitle)
}

// required .KuplungApp.Vec3 AmbientColor = 3;
inline bool MeshModelMaterial::has_ambientcolor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ambientcolor_ != nullptr);
  return value;
}
inline void MeshModelMaterial::clear_ambientcolor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.ambientcolor_ != nullptr) _impl_.ambientcolor_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::KuplungApp::Vec3& MeshModelMaterial::_internal_ambientcolor() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::KuplungApp::Vec3* p = _impl_.ambientcolor_;
  return p != nullptr ? *p : reinterpret_cast<const ::KuplungApp::Vec3&>(::KuplungApp::_Vec3_default_instance_);
}
inline const ::KuplungApp::Vec3& MeshModelMaterial::ambientcolor() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:KuplungApp.MeshModelMaterial.AmbientColor)
  return _internal_ambientcolor();
}
inline void MeshModelMaterial::unsafe_arena_set_allocated_ambientcolor(::KuplungApp::Vec3* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ambientcolor_);
  }
  _impl_.ambientcolor_ = reinterpret_cast<::KuplungApp::Vec3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KuplungApp.MeshModelMaterial.AmbientColor)
}
inline ::KuplungApp::Vec3* MeshModelMaterial::release_ambientcolor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::KuplungApp::Vec3* released = _impl_.ambientcolor_;
  _impl_.ambientcolor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::KuplungApp::Vec3* MeshModelMaterial::unsafe_arena_release_ambientcolor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:KuplungApp.MeshModelMaterial.AmbientColor)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::KuplungApp::Vec3* temp = _impl_.ambientcolor_;
  _impl_.ambientcolor_ = nullptr;
  return temp;
}
inline ::KuplungApp::Vec3* MeshModelMaterial::_internal_mutable_ambientcolor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.ambientcolor_ == nullptr) {
    auto* p = CreateMaybeMessage<::KuplungApp::Vec3>(GetArena());
    _impl_.ambientcolor_ = reinterpret_cast<::KuplungApp::Vec3*>(p);
  }
  return _impl_.ambientcolor_;
}
inline ::KuplungApp::Vec3* MeshModelMaterial::mutable_ambientcolor() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::KuplungApp::Vec3* _msg = _internal_mutable_ambientcolor();
  // @@protoc_insertion_point(field_mutable:KuplungApp.MeshModelMaterial.AmbientColor)
  return _msg;
}
inline void MeshModelMaterial::set_allocated_ambientcolor(::KuplungApp::Vec3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::KuplungApp::Vec3*>(_impl_.ambientcolor_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::KuplungApp::Vec3*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.ambientcolor_ = reinterpret_cast<::KuplungApp::Vec3*>(value);
  // @@protoc_insertion_point(field_set_allocated:KuplungApp.MeshModelMaterial.AmbientColor)
}

// required .KuplungApp.Vec3 DiffuseColor = 4;
inline bool MeshModelMaterial::has_diffusecolor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.diffusecolor_ != nullptr);
  return value;
}
inline void MeshModelMaterial::clear_diffusecolor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.diffusecolor_ != nullptr) _impl_.diffusecolor_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::KuplungApp::Vec3& MeshModelMaterial::_internal_diffusecolor() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::KuplungApp::Vec3* p = _impl_.diffusecolor_;
  return p != nullptr ? *p : reinterpret_cast<const ::KuplungApp::Vec3&>(::KuplungApp::_Vec3_default_instance_);
}
inline const ::KuplungApp::Vec3& MeshModelMaterial::diffusecolor() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:KuplungApp.MeshModelMaterial.DiffuseColor)
  return _internal_diffusecolor();
}
inline void MeshModelMaterial::unsafe_arena_set_allocated_diffusecolor(::KuplungApp::Vec3* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.diffusecolor_);
  }
  _impl_.diffusecolor_ = reinterpret_cast<::KuplungApp::Vec3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KuplungApp.MeshModelMaterial.DiffuseColor)
}
inline ::KuplungApp::Vec3* MeshModelMaterial::release_diffusecolor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::KuplungApp::Vec3* released = _impl_.diffusecolor_;
  _impl_.diffusecolor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::KuplungApp::Vec3* MeshModelMaterial::unsafe_arena_release_diffusecolor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:KuplungApp.MeshModelMaterial.DiffuseColor)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::KuplungApp::Vec3* temp = _impl_.diffusecolor_;
  _impl_.diffusecolor_ = nullptr;
  return temp;
}
inline ::KuplungApp::Vec3* MeshModelMaterial::_internal_mutable_diffusecolor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.diffusecolor_ == nullptr) {
    auto* p = CreateMaybeMessage<::KuplungApp::Vec3>(GetArena());
    _impl_.diffusecolor_ = reinterpret_cast<::KuplungApp::Vec3*>(p);
  }
  return _impl_.diffusecolor_;
}
inline ::KuplungApp::Vec3* MeshModelMaterial::mutable_diffusecolor() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::KuplungApp::Vec3* _msg = _internal_mutable_diffusecolor();
  // @@protoc_insertion_point(field_mutable:KuplungApp.MeshModelMaterial.DiffuseColor)
  return _msg;
}
inline void MeshModelMaterial::set_allocated_diffusecolor(::KuplungApp::Vec3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::KuplungApp::Vec3*>(_impl_.diffusecolor_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::KuplungApp::Vec3*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.diffusecolor_ = reinterpret_cast<::KuplungApp::Vec3*>(value);
  // @@protoc_insertion_point(field_set_allocated:KuplungApp.MeshModelMaterial.DiffuseColor)
}

// required .KuplungApp.Vec3 SpecularColor = 5;
inline bool MeshModelMaterial::has_specularcolor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.specularcolor_ != nullptr);
  return value;
}
inline void MeshModelMaterial::clear_specularcolor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.specularcolor_ != nullptr) _impl_.specularcolor_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::KuplungApp::Vec3& MeshModelMaterial::_internal_specularcolor() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::KuplungApp::Vec3* p = _impl_.specularcolor_;
  return p != nullptr ? *p : reinterpret_cast<const ::KuplungApp::Vec3&>(::KuplungApp::_Vec3_default_instance_);
}
inline const ::KuplungApp::Vec3& MeshModelMaterial::specularcolor() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:KuplungApp.MeshModelMaterial.SpecularColor)
  return _internal_specularcolor();
}
inline void MeshModelMaterial::unsafe_arena_set_allocated_specularcolor(::KuplungApp::Vec3* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.specularcolor_);
  }
  _impl_.specularcolor_ = reinterpret_cast<::KuplungApp::Vec3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KuplungApp.MeshModelMaterial.SpecularColor)
}
inline ::KuplungApp::Vec3* MeshModelMaterial::release_specularcolor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::KuplungApp::Vec3* released = _impl_.specularcolor_;
  _impl_.specularcolor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::KuplungApp::Vec3* MeshModelMaterial::unsafe_arena_release_specularcolor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:KuplungApp.MeshModelMaterial.SpecularColor)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::KuplungApp::Vec3* temp = _impl_.specularcolor_;
  _impl_.specularcolor_ = nullptr;
  return temp;
}
inline ::KuplungApp::Vec3* MeshModelMaterial::_internal_mutable_specularcolor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.specularcolor_ == nullptr) {
    auto* p = CreateMaybeMessage<::KuplungApp::Vec3>(GetArena());
    _impl_.specularcolor_ = reinterpret_cast<::KuplungApp::Vec3*>(p);
  }
  return _impl_.specularcolor_;
}
inline ::KuplungApp::Vec3* MeshModelMaterial::mutable_specularcolor() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::KuplungApp::Vec3* _msg = _internal_mutable_specularcolor();
  // @@protoc_insertion_point(field_mutable:KuplungApp.MeshModelMaterial.SpecularColor)
  return _msg;
}
inline void MeshModelMaterial::set_allocated_specularcolor(::KuplungApp::Vec3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::KuplungApp::Vec3*>(_impl_.specularcolor_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::KuplungApp::Vec3*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.specularcolor_ = reinterpret_cast<::KuplungApp::Vec3*>(value);
  // @@protoc_insertion_point(field_set_allocated:KuplungApp.MeshModelMaterial.SpecularColor)
}

// required .KuplungApp.Vec3 EmissionColor = 6;
inline bool MeshModelMaterial::has_emissioncolor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.emissioncolor_ != nullptr);
  return value;
}
inline void MeshModelMaterial::clear_emissioncolor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.emissioncolor_ != nullptr) _impl_.emissioncolor_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::KuplungApp::Vec3& MeshModelMaterial::_internal_emissioncolor() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::KuplungApp::Vec3* p = _impl_.emissioncolor_;
  return p != nullptr ? *p : reinterpret_cast<const ::KuplungApp::Vec3&>(::KuplungApp::_Vec3_default_instance_);
}
inline const ::KuplungApp::Vec3& MeshModelMaterial::emissioncolor() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:KuplungApp.MeshModelMaterial.EmissionColor)
  return _internal_emissioncolor();
}
inline void MeshModelMaterial::unsafe_arena_set_allocated_emissioncolor(::KuplungApp::Vec3* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.emissioncolor_);
  }
  _impl_.emissioncolor_ = reinterpret_cast<::KuplungApp::Vec3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KuplungApp.MeshModelMaterial.EmissionColor)
}
inline ::KuplungApp::Vec3* MeshModelMaterial::release_emissioncolor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::KuplungApp::Vec3* released = _impl_.emissioncolor_;
  _impl_.emissioncolor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::KuplungApp::Vec3* MeshModelMaterial::unsafe_arena_release_emissioncolor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:KuplungApp.MeshModelMaterial.EmissionColor)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::KuplungApp::Vec3* temp = _impl_.emissioncolor_;
  _impl_.emissioncolor_ = nullptr;
  return temp;
}
inline ::KuplungApp::Vec3* MeshModelMaterial::_internal_mutable_emissioncolor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.emissioncolor_ == nullptr) {
    auto* p = CreateMaybeMessage<::KuplungApp::Vec3>(GetArena());
    _impl_.emissioncolor_ = reinterpret_cast<::KuplungApp::Vec3*>(p);
  }
  return _impl_.emissioncolor_;
}
inline ::KuplungApp::Vec3* MeshModelMaterial::mutable_emissioncolor() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::KuplungApp::Vec3* _msg = _internal_mutable_emissioncolor();
  // @@protoc_insertion_point(field_mutable:KuplungApp.MeshModelMaterial.EmissionColor)
  return _msg;
}
inline void MeshModelMaterial::set_allocated_emissioncolor(::KuplungApp::Vec3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::KuplungApp::Vec3*>(_impl_.emissioncolor_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::KuplungApp::Vec3*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.emissioncolor_ = reinterpret_cast<::KuplungApp::Vec3*>(value);
  // @@protoc_insertion_point(field_set_allocated:KuplungApp.MeshModelMaterial.EmissionColor)
}

// required float SpecularExp = 7;
inline bool MeshModelMaterial::has_specularexp() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline void MeshModelMaterial::clear_specularexp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.specularexp_ = 0;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline float MeshModelMaterial::specularexp() const {
  // @@protoc_insertion_point(field_get:KuplungApp.MeshModelMaterial.SpecularExp)
  return _internal_specularexp();
}
inline void MeshModelMaterial::set_specularexp(float value) {
  _internal_set_specularexp(value);
  // @@protoc_insertion_point(field_set:KuplungApp.MeshModelMaterial.SpecularExp)
}
inline float MeshModelMaterial::_internal_specularexp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.specularexp_;
}
inline void MeshModelMaterial::_internal_set_specularexp(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.specularexp_ = value;
}

// required float Transparency = 8;
inline bool MeshModelMaterial::has_transparency() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline void MeshModelMaterial::clear_transparency() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.transparency_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline float MeshModelMaterial::transparency() const {
  // @@protoc_insertion_point(field_get:KuplungApp.MeshModelMaterial.Transparency)
  return _internal_transparency();
}
inline void MeshModelMaterial::set_transparency(float value) {
  _internal_set_transparency(value);
  // @@protoc_insertion_point(field_set:KuplungApp.MeshModelMaterial.Transparency)
}
inline float MeshModelMaterial::_internal_transparency() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.transparency_;
}
inline void MeshModelMaterial::_internal_set_transparency(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.transparency_ = value;
}

// required fixed32 IlluminationMode = 9;
inline bool MeshModelMaterial::has_illuminationmode() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline void MeshModelMaterial::clear_illuminationmode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.illuminationmode_ = 0u;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline ::uint32_t MeshModelMaterial::illuminationmode() const {
  // @@protoc_insertion_point(field_get:KuplungApp.MeshModelMaterial.IlluminationMode)
  return _internal_illuminationmode();
}
inline void MeshModelMaterial::set_illuminationmode(::uint32_t value) {
  _internal_set_illuminationmode(value);
  // @@protoc_insertion_point(field_set:KuplungApp.MeshModelMaterial.IlluminationMode)
}
inline ::uint32_t MeshModelMaterial::_internal_illuminationmode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.illuminationmode_;
}
inline void MeshModelMaterial::_internal_set_illuminationmode(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.illuminationmode_ = value;
}

// required float OpticalDensity = 10;
inline bool MeshModelMaterial::has_opticaldensity() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline void MeshModelMaterial::clear_opticaldensity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.opticaldensity_ = 0;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline float MeshModelMaterial::opticaldensity() const {
  // @@protoc_insertion_point(field_get:KuplungApp.MeshModelMaterial.OpticalDensity)
  return _internal_opticaldensity();
}
inline void MeshModelMaterial::set_opticaldensity(float value) {
  _internal_set_opticaldensity(value);
  // @@protoc_insertion_point(field_set:KuplungApp.MeshModelMaterial.OpticalDensity)
}
inline float MeshModelMaterial::_internal_opticaldensity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.opticaldensity_;
}
inline void MeshModelMaterial::_internal_set_opticaldensity(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.opticaldensity_ = value;
}

// required .KuplungApp.MeshMaterialTextureImage TextureAmbient = 11;
inline bool MeshModelMaterial::has_textureambient() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.textureambient_ != nullptr);
  return value;
}
inline void MeshModelMaterial::clear_textureambient() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.textureambient_ != nullptr) _impl_.textureambient_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::KuplungApp::MeshMaterialTextureImage& MeshModelMaterial::_internal_textureambient() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::KuplungApp::MeshMaterialTextureImage* p = _impl_.textureambient_;
  return p != nullptr ? *p : reinterpret_cast<const ::KuplungApp::MeshMaterialTextureImage&>(::KuplungApp::_MeshMaterialTextureImage_default_instance_);
}
inline const ::KuplungApp::MeshMaterialTextureImage& MeshModelMaterial::textureambient() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:KuplungApp.MeshModelMaterial.TextureAmbient)
  return _internal_textureambient();
}
inline void MeshModelMaterial::unsafe_arena_set_allocated_textureambient(::KuplungApp::MeshMaterialTextureImage* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.textureambient_);
  }
  _impl_.textureambient_ = reinterpret_cast<::KuplungApp::MeshMaterialTextureImage*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KuplungApp.MeshModelMaterial.TextureAmbient)
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::release_textureambient() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::KuplungApp::MeshMaterialTextureImage* released = _impl_.textureambient_;
  _impl_.textureambient_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::unsafe_arena_release_textureambient() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:KuplungApp.MeshModelMaterial.TextureAmbient)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::KuplungApp::MeshMaterialTextureImage* temp = _impl_.textureambient_;
  _impl_.textureambient_ = nullptr;
  return temp;
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::_internal_mutable_textureambient() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.textureambient_ == nullptr) {
    auto* p = CreateMaybeMessage<::KuplungApp::MeshMaterialTextureImage>(GetArena());
    _impl_.textureambient_ = reinterpret_cast<::KuplungApp::MeshMaterialTextureImage*>(p);
  }
  return _impl_.textureambient_;
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::mutable_textureambient() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::KuplungApp::MeshMaterialTextureImage* _msg = _internal_mutable_textureambient();
  // @@protoc_insertion_point(field_mutable:KuplungApp.MeshModelMaterial.TextureAmbient)
  return _msg;
}
inline void MeshModelMaterial::set_allocated_textureambient(::KuplungApp::MeshMaterialTextureImage* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::KuplungApp::MeshMaterialTextureImage*>(_impl_.textureambient_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::KuplungApp::MeshMaterialTextureImage*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.textureambient_ = reinterpret_cast<::KuplungApp::MeshMaterialTextureImage*>(value);
  // @@protoc_insertion_point(field_set_allocated:KuplungApp.MeshModelMaterial.TextureAmbient)
}

// required .KuplungApp.MeshMaterialTextureImage TextureDiffuse = 12;
inline bool MeshModelMaterial::has_texturediffuse() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.texturediffuse_ != nullptr);
  return value;
}
inline void MeshModelMaterial::clear_texturediffuse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.texturediffuse_ != nullptr) _impl_.texturediffuse_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::KuplungApp::MeshMaterialTextureImage& MeshModelMaterial::_internal_texturediffuse() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::KuplungApp::MeshMaterialTextureImage* p = _impl_.texturediffuse_;
  return p != nullptr ? *p : reinterpret_cast<const ::KuplungApp::MeshMaterialTextureImage&>(::KuplungApp::_MeshMaterialTextureImage_default_instance_);
}
inline const ::KuplungApp::MeshMaterialTextureImage& MeshModelMaterial::texturediffuse() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:KuplungApp.MeshModelMaterial.TextureDiffuse)
  return _internal_texturediffuse();
}
inline void MeshModelMaterial::unsafe_arena_set_allocated_texturediffuse(::KuplungApp::MeshMaterialTextureImage* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.texturediffuse_);
  }
  _impl_.texturediffuse_ = reinterpret_cast<::KuplungApp::MeshMaterialTextureImage*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KuplungApp.MeshModelMaterial.TextureDiffuse)
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::release_texturediffuse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::KuplungApp::MeshMaterialTextureImage* released = _impl_.texturediffuse_;
  _impl_.texturediffuse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::unsafe_arena_release_texturediffuse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:KuplungApp.MeshModelMaterial.TextureDiffuse)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::KuplungApp::MeshMaterialTextureImage* temp = _impl_.texturediffuse_;
  _impl_.texturediffuse_ = nullptr;
  return temp;
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::_internal_mutable_texturediffuse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.texturediffuse_ == nullptr) {
    auto* p = CreateMaybeMessage<::KuplungApp::MeshMaterialTextureImage>(GetArena());
    _impl_.texturediffuse_ = reinterpret_cast<::KuplungApp::MeshMaterialTextureImage*>(p);
  }
  return _impl_.texturediffuse_;
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::mutable_texturediffuse() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::KuplungApp::MeshMaterialTextureImage* _msg = _internal_mutable_texturediffuse();
  // @@protoc_insertion_point(field_mutable:KuplungApp.MeshModelMaterial.TextureDiffuse)
  return _msg;
}
inline void MeshModelMaterial::set_allocated_texturediffuse(::KuplungApp::MeshMaterialTextureImage* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::KuplungApp::MeshMaterialTextureImage*>(_impl_.texturediffuse_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::KuplungApp::MeshMaterialTextureImage*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.texturediffuse_ = reinterpret_cast<::KuplungApp::MeshMaterialTextureImage*>(value);
  // @@protoc_insertion_point(field_set_allocated:KuplungApp.MeshModelMaterial.TextureDiffuse)
}

// required .KuplungApp.MeshMaterialTextureImage TextureSpecular = 13;
inline bool MeshModelMaterial::has_texturespecular() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.texturespecular_ != nullptr);
  return value;
}
inline void MeshModelMaterial::clear_texturespecular() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.texturespecular_ != nullptr) _impl_.texturespecular_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::KuplungApp::MeshMaterialTextureImage& MeshModelMaterial::_internal_texturespecular() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::KuplungApp::MeshMaterialTextureImage* p = _impl_.texturespecular_;
  return p != nullptr ? *p : reinterpret_cast<const ::KuplungApp::MeshMaterialTextureImage&>(::KuplungApp::_MeshMaterialTextureImage_default_instance_);
}
inline const ::KuplungApp::MeshMaterialTextureImage& MeshModelMaterial::texturespecular() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:KuplungApp.MeshModelMaterial.TextureSpecular)
  return _internal_texturespecular();
}
inline void MeshModelMaterial::unsafe_arena_set_allocated_texturespecular(::KuplungApp::MeshMaterialTextureImage* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.texturespecular_);
  }
  _impl_.texturespecular_ = reinterpret_cast<::KuplungApp::MeshMaterialTextureImage*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KuplungApp.MeshModelMaterial.TextureSpecular)
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::release_texturespecular() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::KuplungApp::MeshMaterialTextureImage* released = _impl_.texturespecular_;
  _impl_.texturespecular_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::unsafe_arena_release_texturespecular() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:KuplungApp.MeshModelMaterial.TextureSpecular)

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::KuplungApp::MeshMaterialTextureImage* temp = _impl_.texturespecular_;
  _impl_.texturespecular_ = nullptr;
  return temp;
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::_internal_mutable_texturespecular() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.texturespecular_ == nullptr) {
    auto* p = CreateMaybeMessage<::KuplungApp::MeshMaterialTextureImage>(GetArena());
    _impl_.texturespecular_ = reinterpret_cast<::KuplungApp::MeshMaterialTextureImage*>(p);
  }
  return _impl_.texturespecular_;
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::mutable_texturespecular() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::KuplungApp::MeshMaterialTextureImage* _msg = _internal_mutable_texturespecular();
  // @@protoc_insertion_point(field_mutable:KuplungApp.MeshModelMaterial.TextureSpecular)
  return _msg;
}
inline void MeshModelMaterial::set_allocated_texturespecular(::KuplungApp::MeshMaterialTextureImage* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::KuplungApp::MeshMaterialTextureImage*>(_impl_.texturespecular_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::KuplungApp::MeshMaterialTextureImage*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }

  _impl_.texturespecular_ = reinterpret_cast<::KuplungApp::MeshMaterialTextureImage*>(value);
  // @@protoc_insertion_point(field_set_allocated:KuplungApp.MeshModelMaterial.TextureSpecular)
}

// required .KuplungApp.MeshMaterialTextureImage TextureSpecularExp = 14;
inline bool MeshModelMaterial::has_texturespecularexp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.texturespecularexp_ != nullptr);
  return value;
}
inline void MeshModelMaterial::clear_texturespecularexp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.texturespecularexp_ != nullptr) _impl_.texturespecularexp_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::KuplungApp::MeshMaterialTextureImage& MeshModelMaterial::_internal_texturespecularexp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::KuplungApp::MeshMaterialTextureImage* p = _impl_.texturespecularexp_;
  return p != nullptr ? *p : reinterpret_cast<const ::KuplungApp::MeshMaterialTextureImage&>(::KuplungApp::_MeshMaterialTextureImage_default_instance_);
}
inline const ::KuplungApp::MeshMaterialTextureImage& MeshModelMaterial::texturespecularexp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:KuplungApp.MeshModelMaterial.TextureSpecularExp)
  return _internal_texturespecularexp();
}
inline void MeshModelMaterial::unsafe_arena_set_allocated_texturespecularexp(::KuplungApp::MeshMaterialTextureImage* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.texturespecularexp_);
  }
  _impl_.texturespecularexp_ = reinterpret_cast<::KuplungApp::MeshMaterialTextureImage*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KuplungApp.MeshModelMaterial.TextureSpecularExp)
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::release_texturespecularexp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::KuplungApp::MeshMaterialTextureImage* released = _impl_.texturespecularexp_;
  _impl_.texturespecularexp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::unsafe_arena_release_texturespecularexp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:KuplungApp.MeshModelMaterial.TextureSpecularExp)

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::KuplungApp::MeshMaterialTextureImage* temp = _impl_.texturespecularexp_;
  _impl_.texturespecularexp_ = nullptr;
  return temp;
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::_internal_mutable_texturespecularexp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.texturespecularexp_ == nullptr) {
    auto* p = CreateMaybeMessage<::KuplungApp::MeshMaterialTextureImage>(GetArena());
    _impl_.texturespecularexp_ = reinterpret_cast<::KuplungApp::MeshMaterialTextureImage*>(p);
  }
  return _impl_.texturespecularexp_;
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::mutable_texturespecularexp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::KuplungApp::MeshMaterialTextureImage* _msg = _internal_mutable_texturespecularexp();
  // @@protoc_insertion_point(field_mutable:KuplungApp.MeshModelMaterial.TextureSpecularExp)
  return _msg;
}
inline void MeshModelMaterial::set_allocated_texturespecularexp(::KuplungApp::MeshMaterialTextureImage* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::KuplungApp::MeshMaterialTextureImage*>(_impl_.texturespecularexp_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::KuplungApp::MeshMaterialTextureImage*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }

  _impl_.texturespecularexp_ = reinterpret_cast<::KuplungApp::MeshMaterialTextureImage*>(value);
  // @@protoc_insertion_point(field_set_allocated:KuplungApp.MeshModelMaterial.TextureSpecularExp)
}

// required .KuplungApp.MeshMaterialTextureImage TextureDissolve = 15;
inline bool MeshModelMaterial::has_texturedissolve() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.texturedissolve_ != nullptr);
  return value;
}
inline void MeshModelMaterial::clear_texturedissolve() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.texturedissolve_ != nullptr) _impl_.texturedissolve_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::KuplungApp::MeshMaterialTextureImage& MeshModelMaterial::_internal_texturedissolve() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::KuplungApp::MeshMaterialTextureImage* p = _impl_.texturedissolve_;
  return p != nullptr ? *p : reinterpret_cast<const ::KuplungApp::MeshMaterialTextureImage&>(::KuplungApp::_MeshMaterialTextureImage_default_instance_);
}
inline const ::KuplungApp::MeshMaterialTextureImage& MeshModelMaterial::texturedissolve() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:KuplungApp.MeshModelMaterial.TextureDissolve)
  return _internal_texturedissolve();
}
inline void MeshModelMaterial::unsafe_arena_set_allocated_texturedissolve(::KuplungApp::MeshMaterialTextureImage* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.texturedissolve_);
  }
  _impl_.texturedissolve_ = reinterpret_cast<::KuplungApp::MeshMaterialTextureImage*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KuplungApp.MeshModelMaterial.TextureDissolve)
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::release_texturedissolve() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::KuplungApp::MeshMaterialTextureImage* released = _impl_.texturedissolve_;
  _impl_.texturedissolve_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::unsafe_arena_release_texturedissolve() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:KuplungApp.MeshModelMaterial.TextureDissolve)

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::KuplungApp::MeshMaterialTextureImage* temp = _impl_.texturedissolve_;
  _impl_.texturedissolve_ = nullptr;
  return temp;
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::_internal_mutable_texturedissolve() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.texturedissolve_ == nullptr) {
    auto* p = CreateMaybeMessage<::KuplungApp::MeshMaterialTextureImage>(GetArena());
    _impl_.texturedissolve_ = reinterpret_cast<::KuplungApp::MeshMaterialTextureImage*>(p);
  }
  return _impl_.texturedissolve_;
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::mutable_texturedissolve() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::KuplungApp::MeshMaterialTextureImage* _msg = _internal_mutable_texturedissolve();
  // @@protoc_insertion_point(field_mutable:KuplungApp.MeshModelMaterial.TextureDissolve)
  return _msg;
}
inline void MeshModelMaterial::set_allocated_texturedissolve(::KuplungApp::MeshMaterialTextureImage* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::KuplungApp::MeshMaterialTextureImage*>(_impl_.texturedissolve_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::KuplungApp::MeshMaterialTextureImage*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }

  _impl_.texturedissolve_ = reinterpret_cast<::KuplungApp::MeshMaterialTextureImage*>(value);
  // @@protoc_insertion_point(field_set_allocated:KuplungApp.MeshModelMaterial.TextureDissolve)
}

// required .KuplungApp.MeshMaterialTextureImage TextureBump = 16;
inline bool MeshModelMaterial::has_texturebump() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.texturebump_ != nullptr);
  return value;
}
inline void MeshModelMaterial::clear_texturebump() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.texturebump_ != nullptr) _impl_.texturebump_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const ::KuplungApp::MeshMaterialTextureImage& MeshModelMaterial::_internal_texturebump() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::KuplungApp::MeshMaterialTextureImage* p = _impl_.texturebump_;
  return p != nullptr ? *p : reinterpret_cast<const ::KuplungApp::MeshMaterialTextureImage&>(::KuplungApp::_MeshMaterialTextureImage_default_instance_);
}
inline const ::KuplungApp::MeshMaterialTextureImage& MeshModelMaterial::texturebump() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:KuplungApp.MeshModelMaterial.TextureBump)
  return _internal_texturebump();
}
inline void MeshModelMaterial::unsafe_arena_set_allocated_texturebump(::KuplungApp::MeshMaterialTextureImage* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.texturebump_);
  }
  _impl_.texturebump_ = reinterpret_cast<::KuplungApp::MeshMaterialTextureImage*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KuplungApp.MeshModelMaterial.TextureBump)
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::release_texturebump() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000400u;
  ::KuplungApp::MeshMaterialTextureImage* released = _impl_.texturebump_;
  _impl_.texturebump_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::unsafe_arena_release_texturebump() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:KuplungApp.MeshModelMaterial.TextureBump)

  _impl_._has_bits_[0] &= ~0x00000400u;
  ::KuplungApp::MeshMaterialTextureImage* temp = _impl_.texturebump_;
  _impl_.texturebump_ = nullptr;
  return temp;
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::_internal_mutable_texturebump() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000400u;
  if (_impl_.texturebump_ == nullptr) {
    auto* p = CreateMaybeMessage<::KuplungApp::MeshMaterialTextureImage>(GetArena());
    _impl_.texturebump_ = reinterpret_cast<::KuplungApp::MeshMaterialTextureImage*>(p);
  }
  return _impl_.texturebump_;
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::mutable_texturebump() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::KuplungApp::MeshMaterialTextureImage* _msg = _internal_mutable_texturebump();
  // @@protoc_insertion_point(field_mutable:KuplungApp.MeshModelMaterial.TextureBump)
  return _msg;
}
inline void MeshModelMaterial::set_allocated_texturebump(::KuplungApp::MeshMaterialTextureImage* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::KuplungApp::MeshMaterialTextureImage*>(_impl_.texturebump_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::KuplungApp::MeshMaterialTextureImage*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }

  _impl_.texturebump_ = reinterpret_cast<::KuplungApp::MeshMaterialTextureImage*>(value);
  // @@protoc_insertion_point(field_set_allocated:KuplungApp.MeshModelMaterial.TextureBump)
}

// required .KuplungApp.MeshMaterialTextureImage TextureDisplacement = 17;
inline bool MeshModelMaterial::has_texturedisplacement() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.texturedisplacement_ != nullptr);
  return value;
}
inline void MeshModelMaterial::clear_texturedisplacement() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.texturedisplacement_ != nullptr) _impl_.texturedisplacement_->Clear();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const ::KuplungApp::MeshMaterialTextureImage& MeshModelMaterial::_internal_texturedisplacement() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::KuplungApp::MeshMaterialTextureImage* p = _impl_.texturedisplacement_;
  return p != nullptr ? *p : reinterpret_cast<const ::KuplungApp::MeshMaterialTextureImage&>(::KuplungApp::_MeshMaterialTextureImage_default_instance_);
}
inline const ::KuplungApp::MeshMaterialTextureImage& MeshModelMaterial::texturedisplacement() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:KuplungApp.MeshModelMaterial.TextureDisplacement)
  return _internal_texturedisplacement();
}
inline void MeshModelMaterial::unsafe_arena_set_allocated_texturedisplacement(::KuplungApp::MeshMaterialTextureImage* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.texturedisplacement_);
  }
  _impl_.texturedisplacement_ = reinterpret_cast<::KuplungApp::MeshMaterialTextureImage*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KuplungApp.MeshModelMaterial.TextureDisplacement)
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::release_texturedisplacement() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000800u;
  ::KuplungApp::MeshMaterialTextureImage* released = _impl_.texturedisplacement_;
  _impl_.texturedisplacement_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::unsafe_arena_release_texturedisplacement() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:KuplungApp.MeshModelMaterial.TextureDisplacement)

  _impl_._has_bits_[0] &= ~0x00000800u;
  ::KuplungApp::MeshMaterialTextureImage* temp = _impl_.texturedisplacement_;
  _impl_.texturedisplacement_ = nullptr;
  return temp;
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::_internal_mutable_texturedisplacement() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000800u;
  if (_impl_.texturedisplacement_ == nullptr) {
    auto* p = CreateMaybeMessage<::KuplungApp::MeshMaterialTextureImage>(GetArena());
    _impl_.texturedisplacement_ = reinterpret_cast<::KuplungApp::MeshMaterialTextureImage*>(p);
  }
  return _impl_.texturedisplacement_;
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::mutable_texturedisplacement() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::KuplungApp::MeshMaterialTextureImage* _msg = _internal_mutable_texturedisplacement();
  // @@protoc_insertion_point(field_mutable:KuplungApp.MeshModelMaterial.TextureDisplacement)
  return _msg;
}
inline void MeshModelMaterial::set_allocated_texturedisplacement(::KuplungApp::MeshMaterialTextureImage* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::KuplungApp::MeshMaterialTextureImage*>(_impl_.texturedisplacement_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::KuplungApp::MeshMaterialTextureImage*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }

  _impl_.texturedisplacement_ = reinterpret_cast<::KuplungApp::MeshMaterialTextureImage*>(value);
  // @@protoc_insertion_point(field_set_allocated:KuplungApp.MeshModelMaterial.TextureDisplacement)
}

// -------------------------------------------------------------------

// Mesh

// required int32 ID = 1;
inline bool Mesh::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void Mesh::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t Mesh::id() const {
  // @@protoc_insertion_point(field_get:KuplungApp.Mesh.ID)
  return _internal_id();
}
inline void Mesh::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:KuplungApp.Mesh.ID)
}
inline ::int32_t Mesh::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void Mesh::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.id_ = value;
}

// required .KuplungApp.FBEntity File = 2;
inline bool Mesh::has_file() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.file_ != nullptr);
  return value;
}
inline void Mesh::clear_file() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.file_ != nullptr) _impl_.file_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::KuplungApp::FBEntity& Mesh::_internal_file() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::KuplungApp::FBEntity* p = _impl_.file_;
  return p != nullptr ? *p : reinterpret_cast<const ::KuplungApp::FBEntity&>(::KuplungApp::_FBEntity_default_instance_);
}
inline const ::KuplungApp::FBEntity& Mesh::file() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:KuplungApp.Mesh.File)
  return _internal_file();
}
inline void Mesh::unsafe_arena_set_allocated_file(::KuplungApp::FBEntity* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.file_);
  }
  _impl_.file_ = reinterpret_cast<::KuplungApp::FBEntity*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KuplungApp.Mesh.File)
}
inline ::KuplungApp::FBEntity* Mesh::release_file() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::KuplungApp::FBEntity* released = _impl_.file_;
  _impl_.file_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::KuplungApp::FBEntity* Mesh::unsafe_arena_release_file() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:KuplungApp.Mesh.File)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::KuplungApp::FBEntity* temp = _impl_.file_;
  _impl_.file_ = nullptr;
  return temp;
}
inline ::KuplungApp::FBEntity* Mesh::_internal_mutable_file() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.file_ == nullptr) {
    auto* p = CreateMaybeMessage<::KuplungApp::FBEntity>(GetArena());
    _impl_.file_ = reinterpret_cast<::KuplungApp::FBEntity*>(p);
  }
  return _impl_.file_;
}
inline ::KuplungApp::FBEntity* Mesh::mutable_file() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::KuplungApp::FBEntity* _msg = _internal_mutable_file();
  // @@protoc_insertion_point(field_mutable:KuplungApp.Mesh.File)
  return _msg;
}
inline void Mesh::set_allocated_file(::KuplungApp::FBEntity* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::KuplungApp::FBEntity*>(_impl_.file_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::KuplungApp::FBEntity*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.file_ = reinterpret_cast<::KuplungApp::FBEntity*>(value);
  // @@protoc_insertion_point(field_set_allocated:KuplungApp.Mesh.File)
}

// required string ModelTitle = 3;
inline bool Mesh::has_modeltitle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Mesh::clear_modeltitle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.modeltitle_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Mesh::modeltitle() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:KuplungApp.Mesh.ModelTitle)
  return _internal_modeltitle();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Mesh::set_modeltitle(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.modeltitle_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:KuplungApp.Mesh.ModelTitle)
}
inline std::string* Mesh::mutable_modeltitle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_modeltitle();
  // @@protoc_insertion_point(field_mutable:KuplungApp.Mesh.ModelTitle)
  return _s;
}
inline const std::string& Mesh::_internal_modeltitle() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.modeltitle_.Get();
}
inline void Mesh::_internal_set_modeltitle(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.modeltitle_.Set(value, GetArena());
}
inline std::string* Mesh::_internal_mutable_modeltitle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.modeltitle_.Mutable( GetArena());
}
inline std::string* Mesh::release_modeltitle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:KuplungApp.Mesh.ModelTitle)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.modeltitle_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.modeltitle_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Mesh::set_allocated_modeltitle(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.modeltitle_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.modeltitle_.IsDefault()) {
          _impl_.modeltitle_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KuplungApp.Mesh.ModelTitle)
}

// required string MaterialTitle = 4;
inline bool Mesh::has_materialtitle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Mesh::clear_materialtitle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.materialtitle_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Mesh::materialtitle() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:KuplungApp.Mesh.MaterialTitle)
  return _internal_materialtitle();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Mesh::set_materialtitle(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.materialtitle_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:KuplungApp.Mesh.MaterialTitle)
}
inline std::string* Mesh::mutable_materialtitle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_materialtitle();
  // @@protoc_insertion_point(field_mutable:KuplungApp.Mesh.MaterialTitle)
  return _s;
}
inline const std::string& Mesh::_internal_materialtitle() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.materialtitle_.Get();
}
inline void Mesh::_internal_set_materialtitle(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.materialtitle_.Set(value, GetArena());
}
inline std::string* Mesh::_internal_mutable_materialtitle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.materialtitle_.Mutable( GetArena());
}
inline std::string* Mesh::release_materialtitle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:KuplungApp.Mesh.MaterialTitle)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.materialtitle_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.materialtitle_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Mesh::set_allocated_materialtitle(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.materialtitle_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.materialtitle_.IsDefault()) {
          _impl_.materialtitle_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KuplungApp.Mesh.MaterialTitle)
}

// required int32 countVertices = 5;
inline bool Mesh::has_countvertices() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void Mesh::clear_countvertices() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.countvertices_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t Mesh::countvertices() const {
  // @@protoc_insertion_point(field_get:KuplungApp.Mesh.countVertices)
  return _internal_countvertices();
}
inline void Mesh::set_countvertices(::int32_t value) {
  _internal_set_countvertices(value);
  // @@protoc_insertion_point(field_set:KuplungApp.Mesh.countVertices)
}
inline ::int32_t Mesh::_internal_countvertices() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.countvertices_;
}
inline void Mesh::_internal_set_countvertices(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.countvertices_ = value;
}

// required int32 countTextureCoordinates = 6;
inline bool Mesh::has_counttexturecoordinates() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void Mesh::clear_counttexturecoordinates() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.counttexturecoordinates_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int32_t Mesh::counttexturecoordinates() const {
  // @@protoc_insertion_point(field_get:KuplungApp.Mesh.countTextureCoordinates)
  return _internal_counttexturecoordinates();
}
inline void Mesh::set_counttexturecoordinates(::int32_t value) {
  _internal_set_counttexturecoordinates(value);
  // @@protoc_insertion_point(field_set:KuplungApp.Mesh.countTextureCoordinates)
}
inline ::int32_t Mesh::_internal_counttexturecoordinates() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.counttexturecoordinates_;
}
inline void Mesh::_internal_set_counttexturecoordinates(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.counttexturecoordinates_ = value;
}

// required int32 countNormals = 7;
inline bool Mesh::has_countnormals() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void Mesh::clear_countnormals() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.countnormals_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::int32_t Mesh::countnormals() const {
  // @@protoc_insertion_point(field_get:KuplungApp.Mesh.countNormals)
  return _internal_countnormals();
}
inline void Mesh::set_countnormals(::int32_t value) {
  _internal_set_countnormals(value);
  // @@protoc_insertion_point(field_set:KuplungApp.Mesh.countNormals)
}
inline ::int32_t Mesh::_internal_countnormals() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.countnormals_;
}
inline void Mesh::_internal_set_countnormals(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.countnormals_ = value;
}

// required int32 countIndices = 8;
inline bool Mesh::has_countindices() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void Mesh::clear_countindices() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.countindices_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::int32_t Mesh::countindices() const {
  // @@protoc_insertion_point(field_get:KuplungApp.Mesh.countIndices)
  return _internal_countindices();
}
inline void Mesh::set_countindices(::int32_t value) {
  _internal_set_countindices(value);
  // @@protoc_insertion_point(field_set:KuplungApp.Mesh.countIndices)
}
inline ::int32_t Mesh::_internal_countindices() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.countindices_;
}
inline void Mesh::_internal_set_countindices(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.countindices_ = value;
}

// required .KuplungApp.MeshModelMaterial ModelMaterial = 9;
inline bool Mesh::has_modelmaterial() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.modelmaterial_ != nullptr);
  return value;
}
inline void Mesh::clear_modelmaterial() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.modelmaterial_ != nullptr) _impl_.modelmaterial_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::KuplungApp::MeshModelMaterial& Mesh::_internal_modelmaterial() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::KuplungApp::MeshModelMaterial* p = _impl_.modelmaterial_;
  return p != nullptr ? *p : reinterpret_cast<const ::KuplungApp::MeshModelMaterial&>(::KuplungApp::_MeshModelMaterial_default_instance_);
}
inline const ::KuplungApp::MeshModelMaterial& Mesh::modelmaterial() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:KuplungApp.Mesh.ModelMaterial)
  return _internal_modelmaterial();
}
inline void Mesh::unsafe_arena_set_allocated_modelmaterial(::KuplungApp::MeshModelMaterial* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.modelmaterial_);
  }
  _impl_.modelmaterial_ = reinterpret_cast<::KuplungApp::MeshModelMaterial*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KuplungApp.Mesh.ModelMaterial)
}
inline ::KuplungApp::MeshModelMaterial* Mesh::release_modelmaterial() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::KuplungApp::MeshModelMaterial* released = _impl_.modelmaterial_;
  _impl_.modelmaterial_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::KuplungApp::MeshModelMaterial* Mesh::unsafe_arena_release_modelmaterial() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:KuplungApp.Mesh.ModelMaterial)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::KuplungApp::MeshModelMaterial* temp = _impl_.modelmaterial_;
  _impl_.modelmaterial_ = nullptr;
  return temp;
}
inline ::KuplungApp::MeshModelMaterial* Mesh::_internal_mutable_modelmaterial() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.modelmaterial_ == nullptr) {
    auto* p = CreateMaybeMessage<::KuplungApp::MeshModelMaterial>(GetArena());
    _impl_.modelmaterial_ = reinterpret_cast<::KuplungApp::MeshModelMaterial*>(p);
  }
  return _impl_.modelmaterial_;
}
inline ::KuplungApp::MeshModelMaterial* Mesh::mutable_modelmaterial() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::KuplungApp::MeshModelMaterial* _msg = _internal_mutable_modelmaterial();
  // @@protoc_insertion_point(field_mutable:KuplungApp.Mesh.ModelMaterial)
  return _msg;
}
inline void Mesh::set_allocated_modelmaterial(::KuplungApp::MeshModelMaterial* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::KuplungApp::MeshModelMaterial*>(_impl_.modelmaterial_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::KuplungApp::MeshModelMaterial*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.modelmaterial_ = reinterpret_cast<::KuplungApp::MeshModelMaterial*>(value);
  // @@protoc_insertion_point(field_set_allocated:KuplungApp.Mesh.ModelMaterial)
}

// repeated .KuplungApp.Vec3 vertices = 10;
inline int Mesh::_internal_vertices_size() const {
  return _internal_vertices().size();
}
inline int Mesh::vertices_size() const {
  return _internal_vertices_size();
}
inline void Mesh::clear_vertices() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.vertices_.Clear();
}
inline ::KuplungApp::Vec3* Mesh::mutable_vertices(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:KuplungApp.Mesh.vertices)
  return _internal_mutable_vertices()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::KuplungApp::Vec3>* Mesh::mutable_vertices()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:KuplungApp.Mesh.vertices)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_vertices();
}
inline const ::KuplungApp::Vec3& Mesh::vertices(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:KuplungApp.Mesh.vertices)
  return _internal_vertices().Get(index);
}
inline ::KuplungApp::Vec3* Mesh::add_vertices() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::KuplungApp::Vec3* _add = _internal_mutable_vertices()->Add();
  // @@protoc_insertion_point(field_add:KuplungApp.Mesh.vertices)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::KuplungApp::Vec3>& Mesh::vertices() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:KuplungApp.Mesh.vertices)
  return _internal_vertices();
}
inline const ::google::protobuf::RepeatedPtrField<::KuplungApp::Vec3>&
Mesh::_internal_vertices() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vertices_;
}
inline ::google::protobuf::RepeatedPtrField<::KuplungApp::Vec3>*
Mesh::_internal_mutable_vertices() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.vertices_;
}

// repeated .KuplungApp.Vec2 texture_coordinates = 11;
inline int Mesh::_internal_texture_coordinates_size() const {
  return _internal_texture_coordinates().size();
}
inline int Mesh::texture_coordinates_size() const {
  return _internal_texture_coordinates_size();
}
inline void Mesh::clear_texture_coordinates() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.texture_coordinates_.Clear();
}
inline ::KuplungApp::Vec2* Mesh::mutable_texture_coordinates(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:KuplungApp.Mesh.texture_coordinates)
  return _internal_mutable_texture_coordinates()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::KuplungApp::Vec2>* Mesh::mutable_texture_coordinates()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:KuplungApp.Mesh.texture_coordinates)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_texture_coordinates();
}
inline const ::KuplungApp::Vec2& Mesh::texture_coordinates(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:KuplungApp.Mesh.texture_coordinates)
  return _internal_texture_coordinates().Get(index);
}
inline ::KuplungApp::Vec2* Mesh::add_texture_coordinates() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::KuplungApp::Vec2* _add = _internal_mutable_texture_coordinates()->Add();
  // @@protoc_insertion_point(field_add:KuplungApp.Mesh.texture_coordinates)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::KuplungApp::Vec2>& Mesh::texture_coordinates() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:KuplungApp.Mesh.texture_coordinates)
  return _internal_texture_coordinates();
}
inline const ::google::protobuf::RepeatedPtrField<::KuplungApp::Vec2>&
Mesh::_internal_texture_coordinates() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.texture_coordinates_;
}
inline ::google::protobuf::RepeatedPtrField<::KuplungApp::Vec2>*
Mesh::_internal_mutable_texture_coordinates() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.texture_coordinates_;
}

// repeated .KuplungApp.Vec3 normals = 12;
inline int Mesh::_internal_normals_size() const {
  return _internal_normals().size();
}
inline int Mesh::normals_size() const {
  return _internal_normals_size();
}
inline void Mesh::clear_normals() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.normals_.Clear();
}
inline ::KuplungApp::Vec3* Mesh::mutable_normals(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:KuplungApp.Mesh.normals)
  return _internal_mutable_normals()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::KuplungApp::Vec3>* Mesh::mutable_normals()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:KuplungApp.Mesh.normals)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_normals();
}
inline const ::KuplungApp::Vec3& Mesh::normals(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:KuplungApp.Mesh.normals)
  return _internal_normals().Get(index);
}
inline ::KuplungApp::Vec3* Mesh::add_normals() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::KuplungApp::Vec3* _add = _internal_mutable_normals()->Add();
  // @@protoc_insertion_point(field_add:KuplungApp.Mesh.normals)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::KuplungApp::Vec3>& Mesh::normals() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:KuplungApp.Mesh.normals)
  return _internal_normals();
}
inline const ::google::protobuf::RepeatedPtrField<::KuplungApp::Vec3>&
Mesh::_internal_normals() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.normals_;
}
inline ::google::protobuf::RepeatedPtrField<::KuplungApp::Vec3>*
Mesh::_internal_mutable_normals() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.normals_;
}

// repeated fixed32 indices = 13;
inline int Mesh::_internal_indices_size() const {
  return _internal_indices().size();
}
inline int Mesh::indices_size() const {
  return _internal_indices_size();
}
inline void Mesh::clear_indices() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.indices_.Clear();
}
inline ::uint32_t Mesh::indices(int index) const {
  // @@protoc_insertion_point(field_get:KuplungApp.Mesh.indices)
  return _internal_indices().Get(index);
}
inline void Mesh::set_indices(int index, ::uint32_t value) {
  _internal_mutable_indices()->Set(index, value);
  // @@protoc_insertion_point(field_set:KuplungApp.Mesh.indices)
}
inline void Mesh::add_indices(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_indices()->Add(value);
  // @@protoc_insertion_point(field_add:KuplungApp.Mesh.indices)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& Mesh::indices() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:KuplungApp.Mesh.indices)
  return _internal_indices();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* Mesh::mutable_indices()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:KuplungApp.Mesh.indices)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_indices();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& Mesh::_internal_indices()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.indices_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* Mesh::_internal_mutable_indices() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.indices_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace KuplungApp


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_KuplungDefinitions_2eproto_2epb_2eh
