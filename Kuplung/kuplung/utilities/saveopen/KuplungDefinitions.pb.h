// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: KuplungDefinitions.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_KuplungDefinitions_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_KuplungDefinitions_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021009 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_KuplungDefinitions_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_KuplungDefinitions_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_KuplungDefinitions_2eproto;
namespace KuplungApp {
class FBEntity;
struct FBEntityDefaultTypeInternal;
extern FBEntityDefaultTypeInternal _FBEntity_default_instance_;
class MaterialColor;
struct MaterialColorDefaultTypeInternal;
extern MaterialColorDefaultTypeInternal _MaterialColor_default_instance_;
class Mesh;
struct MeshDefaultTypeInternal;
extern MeshDefaultTypeInternal _Mesh_default_instance_;
class MeshMaterialTextureImage;
struct MeshMaterialTextureImageDefaultTypeInternal;
extern MeshMaterialTextureImageDefaultTypeInternal _MeshMaterialTextureImage_default_instance_;
class MeshModelMaterial;
struct MeshModelMaterialDefaultTypeInternal;
extern MeshModelMaterialDefaultTypeInternal _MeshModelMaterial_default_instance_;
class ObjectCoordinate;
struct ObjectCoordinateDefaultTypeInternal;
extern ObjectCoordinateDefaultTypeInternal _ObjectCoordinate_default_instance_;
class Vec2;
struct Vec2DefaultTypeInternal;
extern Vec2DefaultTypeInternal _Vec2_default_instance_;
class Vec3;
struct Vec3DefaultTypeInternal;
extern Vec3DefaultTypeInternal _Vec3_default_instance_;
class Vec4;
struct Vec4DefaultTypeInternal;
extern Vec4DefaultTypeInternal _Vec4_default_instance_;
}  // namespace KuplungApp
PROTOBUF_NAMESPACE_OPEN
template<> ::KuplungApp::FBEntity* Arena::CreateMaybeMessage<::KuplungApp::FBEntity>(Arena*);
template<> ::KuplungApp::MaterialColor* Arena::CreateMaybeMessage<::KuplungApp::MaterialColor>(Arena*);
template<> ::KuplungApp::Mesh* Arena::CreateMaybeMessage<::KuplungApp::Mesh>(Arena*);
template<> ::KuplungApp::MeshMaterialTextureImage* Arena::CreateMaybeMessage<::KuplungApp::MeshMaterialTextureImage>(Arena*);
template<> ::KuplungApp::MeshModelMaterial* Arena::CreateMaybeMessage<::KuplungApp::MeshModelMaterial>(Arena*);
template<> ::KuplungApp::ObjectCoordinate* Arena::CreateMaybeMessage<::KuplungApp::ObjectCoordinate>(Arena*);
template<> ::KuplungApp::Vec2* Arena::CreateMaybeMessage<::KuplungApp::Vec2>(Arena*);
template<> ::KuplungApp::Vec3* Arena::CreateMaybeMessage<::KuplungApp::Vec3>(Arena*);
template<> ::KuplungApp::Vec4* Arena::CreateMaybeMessage<::KuplungApp::Vec4>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace KuplungApp {

// ===================================================================

class Vec2 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:KuplungApp.Vec2) */ {
 public:
  inline Vec2() : Vec2(nullptr) {}
  ~Vec2() override;
  explicit PROTOBUF_CONSTEXPR Vec2(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vec2(const Vec2& from);
  Vec2(Vec2&& from) noexcept
    : Vec2() {
    *this = ::std::move(from);
  }

  inline Vec2& operator=(const Vec2& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vec2& operator=(Vec2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vec2& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vec2* internal_default_instance() {
    return reinterpret_cast<const Vec2*>(
               &_Vec2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Vec2& a, Vec2& b) {
    a.Swap(&b);
  }
  inline void Swap(Vec2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vec2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vec2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vec2>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vec2& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Vec2& from) {
    Vec2::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vec2* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "KuplungApp.Vec2";
  }
  protected:
  explicit Vec2(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // required float x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // required float y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // @@protoc_insertion_point(class_scope:KuplungApp.Vec2)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    float x_;
    float y_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KuplungDefinitions_2eproto;
};
// -------------------------------------------------------------------

class Vec3 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:KuplungApp.Vec3) */ {
 public:
  inline Vec3() : Vec3(nullptr) {}
  ~Vec3() override;
  explicit PROTOBUF_CONSTEXPR Vec3(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vec3(const Vec3& from);
  Vec3(Vec3&& from) noexcept
    : Vec3() {
    *this = ::std::move(from);
  }

  inline Vec3& operator=(const Vec3& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vec3& operator=(Vec3&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vec3& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vec3* internal_default_instance() {
    return reinterpret_cast<const Vec3*>(
               &_Vec3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Vec3& a, Vec3& b) {
    a.Swap(&b);
  }
  inline void Swap(Vec3* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vec3* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vec3* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vec3>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vec3& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Vec3& from) {
    Vec3::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vec3* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "KuplungApp.Vec3";
  }
  protected:
  explicit Vec3(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // required float x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // required float y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // required float z = 3;
  bool has_z() const;
  private:
  bool _internal_has_z() const;
  public:
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:KuplungApp.Vec3)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    float x_;
    float y_;
    float z_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KuplungDefinitions_2eproto;
};
// -------------------------------------------------------------------

class Vec4 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:KuplungApp.Vec4) */ {
 public:
  inline Vec4() : Vec4(nullptr) {}
  ~Vec4() override;
  explicit PROTOBUF_CONSTEXPR Vec4(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vec4(const Vec4& from);
  Vec4(Vec4&& from) noexcept
    : Vec4() {
    *this = ::std::move(from);
  }

  inline Vec4& operator=(const Vec4& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vec4& operator=(Vec4&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vec4& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vec4* internal_default_instance() {
    return reinterpret_cast<const Vec4*>(
               &_Vec4_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Vec4& a, Vec4& b) {
    a.Swap(&b);
  }
  inline void Swap(Vec4* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vec4* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vec4* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vec4>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vec4& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Vec4& from) {
    Vec4::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vec4* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "KuplungApp.Vec4";
  }
  protected:
  explicit Vec4(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
    kWFieldNumber = 4,
  };
  // required float x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // required float y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // required float z = 3;
  bool has_z() const;
  private:
  bool _internal_has_z() const;
  public:
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // required float w = 4;
  bool has_w() const;
  private:
  bool _internal_has_w() const;
  public:
  void clear_w();
  float w() const;
  void set_w(float value);
  private:
  float _internal_w() const;
  void _internal_set_w(float value);
  public:

  // @@protoc_insertion_point(class_scope:KuplungApp.Vec4)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    float x_;
    float y_;
    float z_;
    float w_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KuplungDefinitions_2eproto;
};
// -------------------------------------------------------------------

class ObjectCoordinate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:KuplungApp.ObjectCoordinate) */ {
 public:
  inline ObjectCoordinate() : ObjectCoordinate(nullptr) {}
  ~ObjectCoordinate() override;
  explicit PROTOBUF_CONSTEXPR ObjectCoordinate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectCoordinate(const ObjectCoordinate& from);
  ObjectCoordinate(ObjectCoordinate&& from) noexcept
    : ObjectCoordinate() {
    *this = ::std::move(from);
  }

  inline ObjectCoordinate& operator=(const ObjectCoordinate& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectCoordinate& operator=(ObjectCoordinate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectCoordinate& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectCoordinate* internal_default_instance() {
    return reinterpret_cast<const ObjectCoordinate*>(
               &_ObjectCoordinate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ObjectCoordinate& a, ObjectCoordinate& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectCoordinate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectCoordinate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectCoordinate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObjectCoordinate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObjectCoordinate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ObjectCoordinate& from) {
    ObjectCoordinate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectCoordinate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "KuplungApp.ObjectCoordinate";
  }
  protected:
  explicit ObjectCoordinate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnimateFieldNumber = 1,
    kPointFieldNumber = 2,
  };
  // required bool animate = 1;
  bool has_animate() const;
  private:
  bool _internal_has_animate() const;
  public:
  void clear_animate();
  bool animate() const;
  void set_animate(bool value);
  private:
  bool _internal_animate() const;
  void _internal_set_animate(bool value);
  public:

  // required float point = 2;
  bool has_point() const;
  private:
  bool _internal_has_point() const;
  public:
  void clear_point();
  float point() const;
  void set_point(float value);
  private:
  float _internal_point() const;
  void _internal_set_point(float value);
  public:

  // @@protoc_insertion_point(class_scope:KuplungApp.ObjectCoordinate)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool animate_;
    float point_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KuplungDefinitions_2eproto;
};
// -------------------------------------------------------------------

class FBEntity final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:KuplungApp.FBEntity) */ {
 public:
  inline FBEntity() : FBEntity(nullptr) {}
  ~FBEntity() override;
  explicit PROTOBUF_CONSTEXPR FBEntity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FBEntity(const FBEntity& from);
  FBEntity(FBEntity&& from) noexcept
    : FBEntity() {
    *this = ::std::move(from);
  }

  inline FBEntity& operator=(const FBEntity& from) {
    CopyFrom(from);
    return *this;
  }
  inline FBEntity& operator=(FBEntity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FBEntity& default_instance() {
    return *internal_default_instance();
  }
  static inline const FBEntity* internal_default_instance() {
    return reinterpret_cast<const FBEntity*>(
               &_FBEntity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(FBEntity& a, FBEntity& b) {
    a.Swap(&b);
  }
  inline void Swap(FBEntity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FBEntity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FBEntity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FBEntity>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FBEntity& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FBEntity& from) {
    FBEntity::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FBEntity* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "KuplungApp.FBEntity";
  }
  protected:
  explicit FBEntity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 2,
    kTitleFieldNumber = 3,
    kExtensionFieldNumber = 4,
    kModifiedDateFieldNumber = 5,
    kSizeFieldNumber = 6,
    kIsFileFieldNumber = 1,
  };
  // required string path = 2;
  bool has_path() const;
  private:
  bool _internal_has_path() const;
  public:
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // required string title = 3;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // required string extension = 4;
  bool has_extension() const;
  private:
  bool _internal_has_extension() const;
  public:
  void clear_extension();
  const std::string& extension() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_extension(ArgT0&& arg0, ArgT... args);
  std::string* mutable_extension();
  PROTOBUF_NODISCARD std::string* release_extension();
  void set_allocated_extension(std::string* extension);
  private:
  const std::string& _internal_extension() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extension(const std::string& value);
  std::string* _internal_mutable_extension();
  public:

  // required string modifiedDate = 5;
  bool has_modifieddate() const;
  private:
  bool _internal_has_modifieddate() const;
  public:
  void clear_modifieddate();
  const std::string& modifieddate() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_modifieddate(ArgT0&& arg0, ArgT... args);
  std::string* mutable_modifieddate();
  PROTOBUF_NODISCARD std::string* release_modifieddate();
  void set_allocated_modifieddate(std::string* modifieddate);
  private:
  const std::string& _internal_modifieddate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modifieddate(const std::string& value);
  std::string* _internal_mutable_modifieddate();
  public:

  // required string size = 6;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  const std::string& size() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_size(ArgT0&& arg0, ArgT... args);
  std::string* mutable_size();
  PROTOBUF_NODISCARD std::string* release_size();
  void set_allocated_size(std::string* size);
  private:
  const std::string& _internal_size() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_size(const std::string& value);
  std::string* _internal_mutable_size();
  public:

  // required bool isFile = 1;
  bool has_isfile() const;
  private:
  bool _internal_has_isfile() const;
  public:
  void clear_isfile();
  bool isfile() const;
  void set_isfile(bool value);
  private:
  bool _internal_isfile() const;
  void _internal_set_isfile(bool value);
  public:

  // @@protoc_insertion_point(class_scope:KuplungApp.FBEntity)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extension_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modifieddate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr size_;
    bool isfile_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KuplungDefinitions_2eproto;
};
// -------------------------------------------------------------------

class MaterialColor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:KuplungApp.MaterialColor) */ {
 public:
  inline MaterialColor() : MaterialColor(nullptr) {}
  ~MaterialColor() override;
  explicit PROTOBUF_CONSTEXPR MaterialColor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MaterialColor(const MaterialColor& from);
  MaterialColor(MaterialColor&& from) noexcept
    : MaterialColor() {
    *this = ::std::move(from);
  }

  inline MaterialColor& operator=(const MaterialColor& from) {
    CopyFrom(from);
    return *this;
  }
  inline MaterialColor& operator=(MaterialColor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MaterialColor& default_instance() {
    return *internal_default_instance();
  }
  static inline const MaterialColor* internal_default_instance() {
    return reinterpret_cast<const MaterialColor*>(
               &_MaterialColor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MaterialColor& a, MaterialColor& b) {
    a.Swap(&b);
  }
  inline void Swap(MaterialColor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MaterialColor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MaterialColor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MaterialColor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MaterialColor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MaterialColor& from) {
    MaterialColor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MaterialColor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "KuplungApp.MaterialColor";
  }
  protected:
  explicit MaterialColor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 4,
    kColorPickerOpenFieldNumber = 1,
    kAnimateFieldNumber = 2,
    kStrengthFieldNumber = 3,
  };
  // required .KuplungApp.Vec3 color = 4;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::KuplungApp::Vec3& color() const;
  PROTOBUF_NODISCARD ::KuplungApp::Vec3* release_color();
  ::KuplungApp::Vec3* mutable_color();
  void set_allocated_color(::KuplungApp::Vec3* color);
  private:
  const ::KuplungApp::Vec3& _internal_color() const;
  ::KuplungApp::Vec3* _internal_mutable_color();
  public:
  void unsafe_arena_set_allocated_color(
      ::KuplungApp::Vec3* color);
  ::KuplungApp::Vec3* unsafe_arena_release_color();

  // required bool colorPickerOpen = 1;
  bool has_colorpickeropen() const;
  private:
  bool _internal_has_colorpickeropen() const;
  public:
  void clear_colorpickeropen();
  bool colorpickeropen() const;
  void set_colorpickeropen(bool value);
  private:
  bool _internal_colorpickeropen() const;
  void _internal_set_colorpickeropen(bool value);
  public:

  // required bool animate = 2;
  bool has_animate() const;
  private:
  bool _internal_has_animate() const;
  public:
  void clear_animate();
  bool animate() const;
  void set_animate(bool value);
  private:
  bool _internal_animate() const;
  void _internal_set_animate(bool value);
  public:

  // required float strength = 3;
  bool has_strength() const;
  private:
  bool _internal_has_strength() const;
  public:
  void clear_strength();
  float strength() const;
  void set_strength(float value);
  private:
  float _internal_strength() const;
  void _internal_set_strength(float value);
  public:

  // @@protoc_insertion_point(class_scope:KuplungApp.MaterialColor)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::KuplungApp::Vec3* color_;
    bool colorpickeropen_;
    bool animate_;
    float strength_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KuplungDefinitions_2eproto;
};
// -------------------------------------------------------------------

class MeshMaterialTextureImage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:KuplungApp.MeshMaterialTextureImage) */ {
 public:
  inline MeshMaterialTextureImage() : MeshMaterialTextureImage(nullptr) {}
  ~MeshMaterialTextureImage() override;
  explicit PROTOBUF_CONSTEXPR MeshMaterialTextureImage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MeshMaterialTextureImage(const MeshMaterialTextureImage& from);
  MeshMaterialTextureImage(MeshMaterialTextureImage&& from) noexcept
    : MeshMaterialTextureImage() {
    *this = ::std::move(from);
  }

  inline MeshMaterialTextureImage& operator=(const MeshMaterialTextureImage& from) {
    CopyFrom(from);
    return *this;
  }
  inline MeshMaterialTextureImage& operator=(MeshMaterialTextureImage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MeshMaterialTextureImage& default_instance() {
    return *internal_default_instance();
  }
  static inline const MeshMaterialTextureImage* internal_default_instance() {
    return reinterpret_cast<const MeshMaterialTextureImage*>(
               &_MeshMaterialTextureImage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MeshMaterialTextureImage& a, MeshMaterialTextureImage& b) {
    a.Swap(&b);
  }
  inline void Swap(MeshMaterialTextureImage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MeshMaterialTextureImage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MeshMaterialTextureImage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MeshMaterialTextureImage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MeshMaterialTextureImage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MeshMaterialTextureImage& from) {
    MeshMaterialTextureImage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MeshMaterialTextureImage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "KuplungApp.MeshMaterialTextureImage";
  }
  protected:
  explicit MeshMaterialTextureImage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommandsFieldNumber = 6,
    kFilenameFieldNumber = 1,
    kImageFieldNumber = 2,
    kWidthFieldNumber = 3,
    kHeightFieldNumber = 4,
    kUseTextureFieldNumber = 5,
  };
  // repeated string Commands = 6;
  int commands_size() const;
  private:
  int _internal_commands_size() const;
  public:
  void clear_commands();
  const std::string& commands(int index) const;
  std::string* mutable_commands(int index);
  void set_commands(int index, const std::string& value);
  void set_commands(int index, std::string&& value);
  void set_commands(int index, const char* value);
  void set_commands(int index, const char* value, size_t size);
  std::string* add_commands();
  void add_commands(const std::string& value);
  void add_commands(std::string&& value);
  void add_commands(const char* value);
  void add_commands(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& commands() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_commands();
  private:
  const std::string& _internal_commands(int index) const;
  std::string* _internal_add_commands();
  public:

  // required string Filename = 1;
  bool has_filename() const;
  private:
  bool _internal_has_filename() const;
  public:
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // required string Image = 2;
  bool has_image() const;
  private:
  bool _internal_has_image() const;
  public:
  void clear_image();
  const std::string& image() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image();
  PROTOBUF_NODISCARD std::string* release_image();
  void set_allocated_image(std::string* image);
  private:
  const std::string& _internal_image() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image(const std::string& value);
  std::string* _internal_mutable_image();
  public:

  // required int32 Width = 3;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // required int32 Height = 4;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  int32_t height() const;
  void set_height(int32_t value);
  private:
  int32_t _internal_height() const;
  void _internal_set_height(int32_t value);
  public:

  // required bool UseTexture = 5;
  bool has_usetexture() const;
  private:
  bool _internal_has_usetexture() const;
  public:
  void clear_usetexture();
  bool usetexture() const;
  void set_usetexture(bool value);
  private:
  bool _internal_usetexture() const;
  void _internal_set_usetexture(bool value);
  public:

  // @@protoc_insertion_point(class_scope:KuplungApp.MeshMaterialTextureImage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> commands_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_;
    int32_t width_;
    int32_t height_;
    bool usetexture_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KuplungDefinitions_2eproto;
};
// -------------------------------------------------------------------

class MeshModelMaterial final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:KuplungApp.MeshModelMaterial) */ {
 public:
  inline MeshModelMaterial() : MeshModelMaterial(nullptr) {}
  ~MeshModelMaterial() override;
  explicit PROTOBUF_CONSTEXPR MeshModelMaterial(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MeshModelMaterial(const MeshModelMaterial& from);
  MeshModelMaterial(MeshModelMaterial&& from) noexcept
    : MeshModelMaterial() {
    *this = ::std::move(from);
  }

  inline MeshModelMaterial& operator=(const MeshModelMaterial& from) {
    CopyFrom(from);
    return *this;
  }
  inline MeshModelMaterial& operator=(MeshModelMaterial&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MeshModelMaterial& default_instance() {
    return *internal_default_instance();
  }
  static inline const MeshModelMaterial* internal_default_instance() {
    return reinterpret_cast<const MeshModelMaterial*>(
               &_MeshModelMaterial_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(MeshModelMaterial& a, MeshModelMaterial& b) {
    a.Swap(&b);
  }
  inline void Swap(MeshModelMaterial* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MeshModelMaterial* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MeshModelMaterial* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MeshModelMaterial>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MeshModelMaterial& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MeshModelMaterial& from) {
    MeshModelMaterial::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MeshModelMaterial* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "KuplungApp.MeshModelMaterial";
  }
  protected:
  explicit MeshModelMaterial(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaterialTitleFieldNumber = 2,
    kAmbientColorFieldNumber = 3,
    kDiffuseColorFieldNumber = 4,
    kSpecularColorFieldNumber = 5,
    kEmissionColorFieldNumber = 6,
    kTextureAmbientFieldNumber = 11,
    kTextureDiffuseFieldNumber = 12,
    kTextureSpecularFieldNumber = 13,
    kTextureSpecularExpFieldNumber = 14,
    kTextureDissolveFieldNumber = 15,
    kTextureBumpFieldNumber = 16,
    kTextureDisplacementFieldNumber = 17,
    kMaterialIDFieldNumber = 1,
    kSpecularExpFieldNumber = 7,
    kTransparencyFieldNumber = 8,
    kIlluminationModeFieldNumber = 9,
    kOpticalDensityFieldNumber = 10,
  };
  // required string MaterialTitle = 2;
  bool has_materialtitle() const;
  private:
  bool _internal_has_materialtitle() const;
  public:
  void clear_materialtitle();
  const std::string& materialtitle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_materialtitle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_materialtitle();
  PROTOBUF_NODISCARD std::string* release_materialtitle();
  void set_allocated_materialtitle(std::string* materialtitle);
  private:
  const std::string& _internal_materialtitle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_materialtitle(const std::string& value);
  std::string* _internal_mutable_materialtitle();
  public:

  // required .KuplungApp.Vec3 AmbientColor = 3;
  bool has_ambientcolor() const;
  private:
  bool _internal_has_ambientcolor() const;
  public:
  void clear_ambientcolor();
  const ::KuplungApp::Vec3& ambientcolor() const;
  PROTOBUF_NODISCARD ::KuplungApp::Vec3* release_ambientcolor();
  ::KuplungApp::Vec3* mutable_ambientcolor();
  void set_allocated_ambientcolor(::KuplungApp::Vec3* ambientcolor);
  private:
  const ::KuplungApp::Vec3& _internal_ambientcolor() const;
  ::KuplungApp::Vec3* _internal_mutable_ambientcolor();
  public:
  void unsafe_arena_set_allocated_ambientcolor(
      ::KuplungApp::Vec3* ambientcolor);
  ::KuplungApp::Vec3* unsafe_arena_release_ambientcolor();

  // required .KuplungApp.Vec3 DiffuseColor = 4;
  bool has_diffusecolor() const;
  private:
  bool _internal_has_diffusecolor() const;
  public:
  void clear_diffusecolor();
  const ::KuplungApp::Vec3& diffusecolor() const;
  PROTOBUF_NODISCARD ::KuplungApp::Vec3* release_diffusecolor();
  ::KuplungApp::Vec3* mutable_diffusecolor();
  void set_allocated_diffusecolor(::KuplungApp::Vec3* diffusecolor);
  private:
  const ::KuplungApp::Vec3& _internal_diffusecolor() const;
  ::KuplungApp::Vec3* _internal_mutable_diffusecolor();
  public:
  void unsafe_arena_set_allocated_diffusecolor(
      ::KuplungApp::Vec3* diffusecolor);
  ::KuplungApp::Vec3* unsafe_arena_release_diffusecolor();

  // required .KuplungApp.Vec3 SpecularColor = 5;
  bool has_specularcolor() const;
  private:
  bool _internal_has_specularcolor() const;
  public:
  void clear_specularcolor();
  const ::KuplungApp::Vec3& specularcolor() const;
  PROTOBUF_NODISCARD ::KuplungApp::Vec3* release_specularcolor();
  ::KuplungApp::Vec3* mutable_specularcolor();
  void set_allocated_specularcolor(::KuplungApp::Vec3* specularcolor);
  private:
  const ::KuplungApp::Vec3& _internal_specularcolor() const;
  ::KuplungApp::Vec3* _internal_mutable_specularcolor();
  public:
  void unsafe_arena_set_allocated_specularcolor(
      ::KuplungApp::Vec3* specularcolor);
  ::KuplungApp::Vec3* unsafe_arena_release_specularcolor();

  // required .KuplungApp.Vec3 EmissionColor = 6;
  bool has_emissioncolor() const;
  private:
  bool _internal_has_emissioncolor() const;
  public:
  void clear_emissioncolor();
  const ::KuplungApp::Vec3& emissioncolor() const;
  PROTOBUF_NODISCARD ::KuplungApp::Vec3* release_emissioncolor();
  ::KuplungApp::Vec3* mutable_emissioncolor();
  void set_allocated_emissioncolor(::KuplungApp::Vec3* emissioncolor);
  private:
  const ::KuplungApp::Vec3& _internal_emissioncolor() const;
  ::KuplungApp::Vec3* _internal_mutable_emissioncolor();
  public:
  void unsafe_arena_set_allocated_emissioncolor(
      ::KuplungApp::Vec3* emissioncolor);
  ::KuplungApp::Vec3* unsafe_arena_release_emissioncolor();

  // required .KuplungApp.MeshMaterialTextureImage TextureAmbient = 11;
  bool has_textureambient() const;
  private:
  bool _internal_has_textureambient() const;
  public:
  void clear_textureambient();
  const ::KuplungApp::MeshMaterialTextureImage& textureambient() const;
  PROTOBUF_NODISCARD ::KuplungApp::MeshMaterialTextureImage* release_textureambient();
  ::KuplungApp::MeshMaterialTextureImage* mutable_textureambient();
  void set_allocated_textureambient(::KuplungApp::MeshMaterialTextureImage* textureambient);
  private:
  const ::KuplungApp::MeshMaterialTextureImage& _internal_textureambient() const;
  ::KuplungApp::MeshMaterialTextureImage* _internal_mutable_textureambient();
  public:
  void unsafe_arena_set_allocated_textureambient(
      ::KuplungApp::MeshMaterialTextureImage* textureambient);
  ::KuplungApp::MeshMaterialTextureImage* unsafe_arena_release_textureambient();

  // required .KuplungApp.MeshMaterialTextureImage TextureDiffuse = 12;
  bool has_texturediffuse() const;
  private:
  bool _internal_has_texturediffuse() const;
  public:
  void clear_texturediffuse();
  const ::KuplungApp::MeshMaterialTextureImage& texturediffuse() const;
  PROTOBUF_NODISCARD ::KuplungApp::MeshMaterialTextureImage* release_texturediffuse();
  ::KuplungApp::MeshMaterialTextureImage* mutable_texturediffuse();
  void set_allocated_texturediffuse(::KuplungApp::MeshMaterialTextureImage* texturediffuse);
  private:
  const ::KuplungApp::MeshMaterialTextureImage& _internal_texturediffuse() const;
  ::KuplungApp::MeshMaterialTextureImage* _internal_mutable_texturediffuse();
  public:
  void unsafe_arena_set_allocated_texturediffuse(
      ::KuplungApp::MeshMaterialTextureImage* texturediffuse);
  ::KuplungApp::MeshMaterialTextureImage* unsafe_arena_release_texturediffuse();

  // required .KuplungApp.MeshMaterialTextureImage TextureSpecular = 13;
  bool has_texturespecular() const;
  private:
  bool _internal_has_texturespecular() const;
  public:
  void clear_texturespecular();
  const ::KuplungApp::MeshMaterialTextureImage& texturespecular() const;
  PROTOBUF_NODISCARD ::KuplungApp::MeshMaterialTextureImage* release_texturespecular();
  ::KuplungApp::MeshMaterialTextureImage* mutable_texturespecular();
  void set_allocated_texturespecular(::KuplungApp::MeshMaterialTextureImage* texturespecular);
  private:
  const ::KuplungApp::MeshMaterialTextureImage& _internal_texturespecular() const;
  ::KuplungApp::MeshMaterialTextureImage* _internal_mutable_texturespecular();
  public:
  void unsafe_arena_set_allocated_texturespecular(
      ::KuplungApp::MeshMaterialTextureImage* texturespecular);
  ::KuplungApp::MeshMaterialTextureImage* unsafe_arena_release_texturespecular();

  // required .KuplungApp.MeshMaterialTextureImage TextureSpecularExp = 14;
  bool has_texturespecularexp() const;
  private:
  bool _internal_has_texturespecularexp() const;
  public:
  void clear_texturespecularexp();
  const ::KuplungApp::MeshMaterialTextureImage& texturespecularexp() const;
  PROTOBUF_NODISCARD ::KuplungApp::MeshMaterialTextureImage* release_texturespecularexp();
  ::KuplungApp::MeshMaterialTextureImage* mutable_texturespecularexp();
  void set_allocated_texturespecularexp(::KuplungApp::MeshMaterialTextureImage* texturespecularexp);
  private:
  const ::KuplungApp::MeshMaterialTextureImage& _internal_texturespecularexp() const;
  ::KuplungApp::MeshMaterialTextureImage* _internal_mutable_texturespecularexp();
  public:
  void unsafe_arena_set_allocated_texturespecularexp(
      ::KuplungApp::MeshMaterialTextureImage* texturespecularexp);
  ::KuplungApp::MeshMaterialTextureImage* unsafe_arena_release_texturespecularexp();

  // required .KuplungApp.MeshMaterialTextureImage TextureDissolve = 15;
  bool has_texturedissolve() const;
  private:
  bool _internal_has_texturedissolve() const;
  public:
  void clear_texturedissolve();
  const ::KuplungApp::MeshMaterialTextureImage& texturedissolve() const;
  PROTOBUF_NODISCARD ::KuplungApp::MeshMaterialTextureImage* release_texturedissolve();
  ::KuplungApp::MeshMaterialTextureImage* mutable_texturedissolve();
  void set_allocated_texturedissolve(::KuplungApp::MeshMaterialTextureImage* texturedissolve);
  private:
  const ::KuplungApp::MeshMaterialTextureImage& _internal_texturedissolve() const;
  ::KuplungApp::MeshMaterialTextureImage* _internal_mutable_texturedissolve();
  public:
  void unsafe_arena_set_allocated_texturedissolve(
      ::KuplungApp::MeshMaterialTextureImage* texturedissolve);
  ::KuplungApp::MeshMaterialTextureImage* unsafe_arena_release_texturedissolve();

  // required .KuplungApp.MeshMaterialTextureImage TextureBump = 16;
  bool has_texturebump() const;
  private:
  bool _internal_has_texturebump() const;
  public:
  void clear_texturebump();
  const ::KuplungApp::MeshMaterialTextureImage& texturebump() const;
  PROTOBUF_NODISCARD ::KuplungApp::MeshMaterialTextureImage* release_texturebump();
  ::KuplungApp::MeshMaterialTextureImage* mutable_texturebump();
  void set_allocated_texturebump(::KuplungApp::MeshMaterialTextureImage* texturebump);
  private:
  const ::KuplungApp::MeshMaterialTextureImage& _internal_texturebump() const;
  ::KuplungApp::MeshMaterialTextureImage* _internal_mutable_texturebump();
  public:
  void unsafe_arena_set_allocated_texturebump(
      ::KuplungApp::MeshMaterialTextureImage* texturebump);
  ::KuplungApp::MeshMaterialTextureImage* unsafe_arena_release_texturebump();

  // required .KuplungApp.MeshMaterialTextureImage TextureDisplacement = 17;
  bool has_texturedisplacement() const;
  private:
  bool _internal_has_texturedisplacement() const;
  public:
  void clear_texturedisplacement();
  const ::KuplungApp::MeshMaterialTextureImage& texturedisplacement() const;
  PROTOBUF_NODISCARD ::KuplungApp::MeshMaterialTextureImage* release_texturedisplacement();
  ::KuplungApp::MeshMaterialTextureImage* mutable_texturedisplacement();
  void set_allocated_texturedisplacement(::KuplungApp::MeshMaterialTextureImage* texturedisplacement);
  private:
  const ::KuplungApp::MeshMaterialTextureImage& _internal_texturedisplacement() const;
  ::KuplungApp::MeshMaterialTextureImage* _internal_mutable_texturedisplacement();
  public:
  void unsafe_arena_set_allocated_texturedisplacement(
      ::KuplungApp::MeshMaterialTextureImage* texturedisplacement);
  ::KuplungApp::MeshMaterialTextureImage* unsafe_arena_release_texturedisplacement();

  // required int32 MaterialID = 1;
  bool has_materialid() const;
  private:
  bool _internal_has_materialid() const;
  public:
  void clear_materialid();
  int32_t materialid() const;
  void set_materialid(int32_t value);
  private:
  int32_t _internal_materialid() const;
  void _internal_set_materialid(int32_t value);
  public:

  // required float SpecularExp = 7;
  bool has_specularexp() const;
  private:
  bool _internal_has_specularexp() const;
  public:
  void clear_specularexp();
  float specularexp() const;
  void set_specularexp(float value);
  private:
  float _internal_specularexp() const;
  void _internal_set_specularexp(float value);
  public:

  // required float Transparency = 8;
  bool has_transparency() const;
  private:
  bool _internal_has_transparency() const;
  public:
  void clear_transparency();
  float transparency() const;
  void set_transparency(float value);
  private:
  float _internal_transparency() const;
  void _internal_set_transparency(float value);
  public:

  // required fixed32 IlluminationMode = 9;
  bool has_illuminationmode() const;
  private:
  bool _internal_has_illuminationmode() const;
  public:
  void clear_illuminationmode();
  uint32_t illuminationmode() const;
  void set_illuminationmode(uint32_t value);
  private:
  uint32_t _internal_illuminationmode() const;
  void _internal_set_illuminationmode(uint32_t value);
  public:

  // required float OpticalDensity = 10;
  bool has_opticaldensity() const;
  private:
  bool _internal_has_opticaldensity() const;
  public:
  void clear_opticaldensity();
  float opticaldensity() const;
  void set_opticaldensity(float value);
  private:
  float _internal_opticaldensity() const;
  void _internal_set_opticaldensity(float value);
  public:

  // @@protoc_insertion_point(class_scope:KuplungApp.MeshModelMaterial)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr materialtitle_;
    ::KuplungApp::Vec3* ambientcolor_;
    ::KuplungApp::Vec3* diffusecolor_;
    ::KuplungApp::Vec3* specularcolor_;
    ::KuplungApp::Vec3* emissioncolor_;
    ::KuplungApp::MeshMaterialTextureImage* textureambient_;
    ::KuplungApp::MeshMaterialTextureImage* texturediffuse_;
    ::KuplungApp::MeshMaterialTextureImage* texturespecular_;
    ::KuplungApp::MeshMaterialTextureImage* texturespecularexp_;
    ::KuplungApp::MeshMaterialTextureImage* texturedissolve_;
    ::KuplungApp::MeshMaterialTextureImage* texturebump_;
    ::KuplungApp::MeshMaterialTextureImage* texturedisplacement_;
    int32_t materialid_;
    float specularexp_;
    float transparency_;
    uint32_t illuminationmode_;
    float opticaldensity_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KuplungDefinitions_2eproto;
};
// -------------------------------------------------------------------

class Mesh final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:KuplungApp.Mesh) */ {
 public:
  inline Mesh() : Mesh(nullptr) {}
  ~Mesh() override;
  explicit PROTOBUF_CONSTEXPR Mesh(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Mesh(const Mesh& from);
  Mesh(Mesh&& from) noexcept
    : Mesh() {
    *this = ::std::move(from);
  }

  inline Mesh& operator=(const Mesh& from) {
    CopyFrom(from);
    return *this;
  }
  inline Mesh& operator=(Mesh&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Mesh& default_instance() {
    return *internal_default_instance();
  }
  static inline const Mesh* internal_default_instance() {
    return reinterpret_cast<const Mesh*>(
               &_Mesh_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Mesh& a, Mesh& b) {
    a.Swap(&b);
  }
  inline void Swap(Mesh* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Mesh* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Mesh* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Mesh>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Mesh& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Mesh& from) {
    Mesh::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Mesh* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "KuplungApp.Mesh";
  }
  protected:
  explicit Mesh(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVerticesFieldNumber = 10,
    kTextureCoordinatesFieldNumber = 11,
    kNormalsFieldNumber = 12,
    kIndicesFieldNumber = 13,
    kModelTitleFieldNumber = 3,
    kMaterialTitleFieldNumber = 4,
    kFileFieldNumber = 2,
    kModelMaterialFieldNumber = 9,
    kIDFieldNumber = 1,
    kCountVerticesFieldNumber = 5,
    kCountTextureCoordinatesFieldNumber = 6,
    kCountNormalsFieldNumber = 7,
    kCountIndicesFieldNumber = 8,
  };
  // repeated .KuplungApp.Vec3 vertices = 10;
  int vertices_size() const;
  private:
  int _internal_vertices_size() const;
  public:
  void clear_vertices();
  ::KuplungApp::Vec3* mutable_vertices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::KuplungApp::Vec3 >*
      mutable_vertices();
  private:
  const ::KuplungApp::Vec3& _internal_vertices(int index) const;
  ::KuplungApp::Vec3* _internal_add_vertices();
  public:
  const ::KuplungApp::Vec3& vertices(int index) const;
  ::KuplungApp::Vec3* add_vertices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::KuplungApp::Vec3 >&
      vertices() const;

  // repeated .KuplungApp.Vec2 texture_coordinates = 11;
  int texture_coordinates_size() const;
  private:
  int _internal_texture_coordinates_size() const;
  public:
  void clear_texture_coordinates();
  ::KuplungApp::Vec2* mutable_texture_coordinates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::KuplungApp::Vec2 >*
      mutable_texture_coordinates();
  private:
  const ::KuplungApp::Vec2& _internal_texture_coordinates(int index) const;
  ::KuplungApp::Vec2* _internal_add_texture_coordinates();
  public:
  const ::KuplungApp::Vec2& texture_coordinates(int index) const;
  ::KuplungApp::Vec2* add_texture_coordinates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::KuplungApp::Vec2 >&
      texture_coordinates() const;

  // repeated .KuplungApp.Vec3 normals = 12;
  int normals_size() const;
  private:
  int _internal_normals_size() const;
  public:
  void clear_normals();
  ::KuplungApp::Vec3* mutable_normals(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::KuplungApp::Vec3 >*
      mutable_normals();
  private:
  const ::KuplungApp::Vec3& _internal_normals(int index) const;
  ::KuplungApp::Vec3* _internal_add_normals();
  public:
  const ::KuplungApp::Vec3& normals(int index) const;
  ::KuplungApp::Vec3* add_normals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::KuplungApp::Vec3 >&
      normals() const;

  // repeated fixed32 indices = 13;
  int indices_size() const;
  private:
  int _internal_indices_size() const;
  public:
  void clear_indices();
  private:
  uint32_t _internal_indices(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_indices() const;
  void _internal_add_indices(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_indices();
  public:
  uint32_t indices(int index) const;
  void set_indices(int index, uint32_t value);
  void add_indices(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      indices() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_indices();

  // required string ModelTitle = 3;
  bool has_modeltitle() const;
  private:
  bool _internal_has_modeltitle() const;
  public:
  void clear_modeltitle();
  const std::string& modeltitle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_modeltitle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_modeltitle();
  PROTOBUF_NODISCARD std::string* release_modeltitle();
  void set_allocated_modeltitle(std::string* modeltitle);
  private:
  const std::string& _internal_modeltitle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modeltitle(const std::string& value);
  std::string* _internal_mutable_modeltitle();
  public:

  // required string MaterialTitle = 4;
  bool has_materialtitle() const;
  private:
  bool _internal_has_materialtitle() const;
  public:
  void clear_materialtitle();
  const std::string& materialtitle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_materialtitle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_materialtitle();
  PROTOBUF_NODISCARD std::string* release_materialtitle();
  void set_allocated_materialtitle(std::string* materialtitle);
  private:
  const std::string& _internal_materialtitle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_materialtitle(const std::string& value);
  std::string* _internal_mutable_materialtitle();
  public:

  // required .KuplungApp.FBEntity File = 2;
  bool has_file() const;
  private:
  bool _internal_has_file() const;
  public:
  void clear_file();
  const ::KuplungApp::FBEntity& file() const;
  PROTOBUF_NODISCARD ::KuplungApp::FBEntity* release_file();
  ::KuplungApp::FBEntity* mutable_file();
  void set_allocated_file(::KuplungApp::FBEntity* file);
  private:
  const ::KuplungApp::FBEntity& _internal_file() const;
  ::KuplungApp::FBEntity* _internal_mutable_file();
  public:
  void unsafe_arena_set_allocated_file(
      ::KuplungApp::FBEntity* file);
  ::KuplungApp::FBEntity* unsafe_arena_release_file();

  // required .KuplungApp.MeshModelMaterial ModelMaterial = 9;
  bool has_modelmaterial() const;
  private:
  bool _internal_has_modelmaterial() const;
  public:
  void clear_modelmaterial();
  const ::KuplungApp::MeshModelMaterial& modelmaterial() const;
  PROTOBUF_NODISCARD ::KuplungApp::MeshModelMaterial* release_modelmaterial();
  ::KuplungApp::MeshModelMaterial* mutable_modelmaterial();
  void set_allocated_modelmaterial(::KuplungApp::MeshModelMaterial* modelmaterial);
  private:
  const ::KuplungApp::MeshModelMaterial& _internal_modelmaterial() const;
  ::KuplungApp::MeshModelMaterial* _internal_mutable_modelmaterial();
  public:
  void unsafe_arena_set_allocated_modelmaterial(
      ::KuplungApp::MeshModelMaterial* modelmaterial);
  ::KuplungApp::MeshModelMaterial* unsafe_arena_release_modelmaterial();

  // required int32 ID = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // required int32 countVertices = 5;
  bool has_countvertices() const;
  private:
  bool _internal_has_countvertices() const;
  public:
  void clear_countvertices();
  int32_t countvertices() const;
  void set_countvertices(int32_t value);
  private:
  int32_t _internal_countvertices() const;
  void _internal_set_countvertices(int32_t value);
  public:

  // required int32 countTextureCoordinates = 6;
  bool has_counttexturecoordinates() const;
  private:
  bool _internal_has_counttexturecoordinates() const;
  public:
  void clear_counttexturecoordinates();
  int32_t counttexturecoordinates() const;
  void set_counttexturecoordinates(int32_t value);
  private:
  int32_t _internal_counttexturecoordinates() const;
  void _internal_set_counttexturecoordinates(int32_t value);
  public:

  // required int32 countNormals = 7;
  bool has_countnormals() const;
  private:
  bool _internal_has_countnormals() const;
  public:
  void clear_countnormals();
  int32_t countnormals() const;
  void set_countnormals(int32_t value);
  private:
  int32_t _internal_countnormals() const;
  void _internal_set_countnormals(int32_t value);
  public:

  // required int32 countIndices = 8;
  bool has_countindices() const;
  private:
  bool _internal_has_countindices() const;
  public:
  void clear_countindices();
  int32_t countindices() const;
  void set_countindices(int32_t value);
  private:
  int32_t _internal_countindices() const;
  void _internal_set_countindices(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:KuplungApp.Mesh)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::KuplungApp::Vec3 > vertices_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::KuplungApp::Vec2 > texture_coordinates_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::KuplungApp::Vec3 > normals_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > indices_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modeltitle_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr materialtitle_;
    ::KuplungApp::FBEntity* file_;
    ::KuplungApp::MeshModelMaterial* modelmaterial_;
    int32_t id_;
    int32_t countvertices_;
    int32_t counttexturecoordinates_;
    int32_t countnormals_;
    int32_t countindices_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KuplungDefinitions_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Vec2

// required float x = 1;
inline bool Vec2::_internal_has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Vec2::has_x() const {
  return _internal_has_x();
}
inline void Vec2::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float Vec2::_internal_x() const {
  return _impl_.x_;
}
inline float Vec2::x() const {
  // @@protoc_insertion_point(field_get:KuplungApp.Vec2.x)
  return _internal_x();
}
inline void Vec2::_internal_set_x(float value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.x_ = value;
}
inline void Vec2::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:KuplungApp.Vec2.x)
}

// required float y = 2;
inline bool Vec2::_internal_has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Vec2::has_y() const {
  return _internal_has_y();
}
inline void Vec2::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Vec2::_internal_y() const {
  return _impl_.y_;
}
inline float Vec2::y() const {
  // @@protoc_insertion_point(field_get:KuplungApp.Vec2.y)
  return _internal_y();
}
inline void Vec2::_internal_set_y(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.y_ = value;
}
inline void Vec2::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:KuplungApp.Vec2.y)
}

// -------------------------------------------------------------------

// Vec3

// required float x = 1;
inline bool Vec3::_internal_has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Vec3::has_x() const {
  return _internal_has_x();
}
inline void Vec3::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float Vec3::_internal_x() const {
  return _impl_.x_;
}
inline float Vec3::x() const {
  // @@protoc_insertion_point(field_get:KuplungApp.Vec3.x)
  return _internal_x();
}
inline void Vec3::_internal_set_x(float value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.x_ = value;
}
inline void Vec3::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:KuplungApp.Vec3.x)
}

// required float y = 2;
inline bool Vec3::_internal_has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Vec3::has_y() const {
  return _internal_has_y();
}
inline void Vec3::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Vec3::_internal_y() const {
  return _impl_.y_;
}
inline float Vec3::y() const {
  // @@protoc_insertion_point(field_get:KuplungApp.Vec3.y)
  return _internal_y();
}
inline void Vec3::_internal_set_y(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.y_ = value;
}
inline void Vec3::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:KuplungApp.Vec3.y)
}

// required float z = 3;
inline bool Vec3::_internal_has_z() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Vec3::has_z() const {
  return _internal_has_z();
}
inline void Vec3::clear_z() {
  _impl_.z_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float Vec3::_internal_z() const {
  return _impl_.z_;
}
inline float Vec3::z() const {
  // @@protoc_insertion_point(field_get:KuplungApp.Vec3.z)
  return _internal_z();
}
inline void Vec3::_internal_set_z(float value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.z_ = value;
}
inline void Vec3::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:KuplungApp.Vec3.z)
}

// -------------------------------------------------------------------

// Vec4

// required float x = 1;
inline bool Vec4::_internal_has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Vec4::has_x() const {
  return _internal_has_x();
}
inline void Vec4::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float Vec4::_internal_x() const {
  return _impl_.x_;
}
inline float Vec4::x() const {
  // @@protoc_insertion_point(field_get:KuplungApp.Vec4.x)
  return _internal_x();
}
inline void Vec4::_internal_set_x(float value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.x_ = value;
}
inline void Vec4::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:KuplungApp.Vec4.x)
}

// required float y = 2;
inline bool Vec4::_internal_has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Vec4::has_y() const {
  return _internal_has_y();
}
inline void Vec4::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Vec4::_internal_y() const {
  return _impl_.y_;
}
inline float Vec4::y() const {
  // @@protoc_insertion_point(field_get:KuplungApp.Vec4.y)
  return _internal_y();
}
inline void Vec4::_internal_set_y(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.y_ = value;
}
inline void Vec4::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:KuplungApp.Vec4.y)
}

// required float z = 3;
inline bool Vec4::_internal_has_z() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Vec4::has_z() const {
  return _internal_has_z();
}
inline void Vec4::clear_z() {
  _impl_.z_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float Vec4::_internal_z() const {
  return _impl_.z_;
}
inline float Vec4::z() const {
  // @@protoc_insertion_point(field_get:KuplungApp.Vec4.z)
  return _internal_z();
}
inline void Vec4::_internal_set_z(float value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.z_ = value;
}
inline void Vec4::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:KuplungApp.Vec4.z)
}

// required float w = 4;
inline bool Vec4::_internal_has_w() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Vec4::has_w() const {
  return _internal_has_w();
}
inline void Vec4::clear_w() {
  _impl_.w_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float Vec4::_internal_w() const {
  return _impl_.w_;
}
inline float Vec4::w() const {
  // @@protoc_insertion_point(field_get:KuplungApp.Vec4.w)
  return _internal_w();
}
inline void Vec4::_internal_set_w(float value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.w_ = value;
}
inline void Vec4::set_w(float value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:KuplungApp.Vec4.w)
}

// -------------------------------------------------------------------

// ObjectCoordinate

// required bool animate = 1;
inline bool ObjectCoordinate::_internal_has_animate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ObjectCoordinate::has_animate() const {
  return _internal_has_animate();
}
inline void ObjectCoordinate::clear_animate() {
  _impl_.animate_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool ObjectCoordinate::_internal_animate() const {
  return _impl_.animate_;
}
inline bool ObjectCoordinate::animate() const {
  // @@protoc_insertion_point(field_get:KuplungApp.ObjectCoordinate.animate)
  return _internal_animate();
}
inline void ObjectCoordinate::_internal_set_animate(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.animate_ = value;
}
inline void ObjectCoordinate::set_animate(bool value) {
  _internal_set_animate(value);
  // @@protoc_insertion_point(field_set:KuplungApp.ObjectCoordinate.animate)
}

// required float point = 2;
inline bool ObjectCoordinate::_internal_has_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ObjectCoordinate::has_point() const {
  return _internal_has_point();
}
inline void ObjectCoordinate::clear_point() {
  _impl_.point_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float ObjectCoordinate::_internal_point() const {
  return _impl_.point_;
}
inline float ObjectCoordinate::point() const {
  // @@protoc_insertion_point(field_get:KuplungApp.ObjectCoordinate.point)
  return _internal_point();
}
inline void ObjectCoordinate::_internal_set_point(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.point_ = value;
}
inline void ObjectCoordinate::set_point(float value) {
  _internal_set_point(value);
  // @@protoc_insertion_point(field_set:KuplungApp.ObjectCoordinate.point)
}

// -------------------------------------------------------------------

// FBEntity

// required bool isFile = 1;
inline bool FBEntity::_internal_has_isfile() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool FBEntity::has_isfile() const {
  return _internal_has_isfile();
}
inline void FBEntity::clear_isfile() {
  _impl_.isfile_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool FBEntity::_internal_isfile() const {
  return _impl_.isfile_;
}
inline bool FBEntity::isfile() const {
  // @@protoc_insertion_point(field_get:KuplungApp.FBEntity.isFile)
  return _internal_isfile();
}
inline void FBEntity::_internal_set_isfile(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.isfile_ = value;
}
inline void FBEntity::set_isfile(bool value) {
  _internal_set_isfile(value);
  // @@protoc_insertion_point(field_set:KuplungApp.FBEntity.isFile)
}

// required string path = 2;
inline bool FBEntity::_internal_has_path() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FBEntity::has_path() const {
  return _internal_has_path();
}
inline void FBEntity::clear_path() {
  _impl_.path_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FBEntity::path() const {
  // @@protoc_insertion_point(field_get:KuplungApp.FBEntity.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FBEntity::set_path(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:KuplungApp.FBEntity.path)
}
inline std::string* FBEntity::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:KuplungApp.FBEntity.path)
  return _s;
}
inline const std::string& FBEntity::_internal_path() const {
  return _impl_.path_.Get();
}
inline void FBEntity::_internal_set_path(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* FBEntity::_internal_mutable_path() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* FBEntity::release_path() {
  // @@protoc_insertion_point(field_release:KuplungApp.FBEntity.path)
  if (!_internal_has_path()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.path_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FBEntity::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KuplungApp.FBEntity.path)
}

// required string title = 3;
inline bool FBEntity::_internal_has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FBEntity::has_title() const {
  return _internal_has_title();
}
inline void FBEntity::clear_title() {
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& FBEntity::title() const {
  // @@protoc_insertion_point(field_get:KuplungApp.FBEntity.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FBEntity::set_title(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:KuplungApp.FBEntity.title)
}
inline std::string* FBEntity::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:KuplungApp.FBEntity.title)
  return _s;
}
inline const std::string& FBEntity::_internal_title() const {
  return _impl_.title_.Get();
}
inline void FBEntity::_internal_set_title(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* FBEntity::_internal_mutable_title() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* FBEntity::release_title() {
  // @@protoc_insertion_point(field_release:KuplungApp.FBEntity.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FBEntity::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KuplungApp.FBEntity.title)
}

// required string extension = 4;
inline bool FBEntity::_internal_has_extension() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool FBEntity::has_extension() const {
  return _internal_has_extension();
}
inline void FBEntity::clear_extension() {
  _impl_.extension_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& FBEntity::extension() const {
  // @@protoc_insertion_point(field_get:KuplungApp.FBEntity.extension)
  return _internal_extension();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FBEntity::set_extension(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.extension_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:KuplungApp.FBEntity.extension)
}
inline std::string* FBEntity::mutable_extension() {
  std::string* _s = _internal_mutable_extension();
  // @@protoc_insertion_point(field_mutable:KuplungApp.FBEntity.extension)
  return _s;
}
inline const std::string& FBEntity::_internal_extension() const {
  return _impl_.extension_.Get();
}
inline void FBEntity::_internal_set_extension(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.extension_.Set(value, GetArenaForAllocation());
}
inline std::string* FBEntity::_internal_mutable_extension() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.extension_.Mutable(GetArenaForAllocation());
}
inline std::string* FBEntity::release_extension() {
  // @@protoc_insertion_point(field_release:KuplungApp.FBEntity.extension)
  if (!_internal_has_extension()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.extension_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.extension_.IsDefault()) {
    _impl_.extension_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FBEntity::set_allocated_extension(std::string* extension) {
  if (extension != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.extension_.SetAllocated(extension, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.extension_.IsDefault()) {
    _impl_.extension_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KuplungApp.FBEntity.extension)
}

// required string modifiedDate = 5;
inline bool FBEntity::_internal_has_modifieddate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool FBEntity::has_modifieddate() const {
  return _internal_has_modifieddate();
}
inline void FBEntity::clear_modifieddate() {
  _impl_.modifieddate_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& FBEntity::modifieddate() const {
  // @@protoc_insertion_point(field_get:KuplungApp.FBEntity.modifiedDate)
  return _internal_modifieddate();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FBEntity::set_modifieddate(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.modifieddate_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:KuplungApp.FBEntity.modifiedDate)
}
inline std::string* FBEntity::mutable_modifieddate() {
  std::string* _s = _internal_mutable_modifieddate();
  // @@protoc_insertion_point(field_mutable:KuplungApp.FBEntity.modifiedDate)
  return _s;
}
inline const std::string& FBEntity::_internal_modifieddate() const {
  return _impl_.modifieddate_.Get();
}
inline void FBEntity::_internal_set_modifieddate(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.modifieddate_.Set(value, GetArenaForAllocation());
}
inline std::string* FBEntity::_internal_mutable_modifieddate() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.modifieddate_.Mutable(GetArenaForAllocation());
}
inline std::string* FBEntity::release_modifieddate() {
  // @@protoc_insertion_point(field_release:KuplungApp.FBEntity.modifiedDate)
  if (!_internal_has_modifieddate()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.modifieddate_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.modifieddate_.IsDefault()) {
    _impl_.modifieddate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FBEntity::set_allocated_modifieddate(std::string* modifieddate) {
  if (modifieddate != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.modifieddate_.SetAllocated(modifieddate, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.modifieddate_.IsDefault()) {
    _impl_.modifieddate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KuplungApp.FBEntity.modifiedDate)
}

// required string size = 6;
inline bool FBEntity::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool FBEntity::has_size() const {
  return _internal_has_size();
}
inline void FBEntity::clear_size() {
  _impl_.size_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& FBEntity::size() const {
  // @@protoc_insertion_point(field_get:KuplungApp.FBEntity.size)
  return _internal_size();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FBEntity::set_size(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.size_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:KuplungApp.FBEntity.size)
}
inline std::string* FBEntity::mutable_size() {
  std::string* _s = _internal_mutable_size();
  // @@protoc_insertion_point(field_mutable:KuplungApp.FBEntity.size)
  return _s;
}
inline const std::string& FBEntity::_internal_size() const {
  return _impl_.size_.Get();
}
inline void FBEntity::_internal_set_size(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.size_.Set(value, GetArenaForAllocation());
}
inline std::string* FBEntity::_internal_mutable_size() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.size_.Mutable(GetArenaForAllocation());
}
inline std::string* FBEntity::release_size() {
  // @@protoc_insertion_point(field_release:KuplungApp.FBEntity.size)
  if (!_internal_has_size()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.size_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.size_.IsDefault()) {
    _impl_.size_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FBEntity::set_allocated_size(std::string* size) {
  if (size != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.size_.SetAllocated(size, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.size_.IsDefault()) {
    _impl_.size_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KuplungApp.FBEntity.size)
}

// -------------------------------------------------------------------

// MaterialColor

// required bool colorPickerOpen = 1;
inline bool MaterialColor::_internal_has_colorpickeropen() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MaterialColor::has_colorpickeropen() const {
  return _internal_has_colorpickeropen();
}
inline void MaterialColor::clear_colorpickeropen() {
  _impl_.colorpickeropen_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool MaterialColor::_internal_colorpickeropen() const {
  return _impl_.colorpickeropen_;
}
inline bool MaterialColor::colorpickeropen() const {
  // @@protoc_insertion_point(field_get:KuplungApp.MaterialColor.colorPickerOpen)
  return _internal_colorpickeropen();
}
inline void MaterialColor::_internal_set_colorpickeropen(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.colorpickeropen_ = value;
}
inline void MaterialColor::set_colorpickeropen(bool value) {
  _internal_set_colorpickeropen(value);
  // @@protoc_insertion_point(field_set:KuplungApp.MaterialColor.colorPickerOpen)
}

// required bool animate = 2;
inline bool MaterialColor::_internal_has_animate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MaterialColor::has_animate() const {
  return _internal_has_animate();
}
inline void MaterialColor::clear_animate() {
  _impl_.animate_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool MaterialColor::_internal_animate() const {
  return _impl_.animate_;
}
inline bool MaterialColor::animate() const {
  // @@protoc_insertion_point(field_get:KuplungApp.MaterialColor.animate)
  return _internal_animate();
}
inline void MaterialColor::_internal_set_animate(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.animate_ = value;
}
inline void MaterialColor::set_animate(bool value) {
  _internal_set_animate(value);
  // @@protoc_insertion_point(field_set:KuplungApp.MaterialColor.animate)
}

// required float strength = 3;
inline bool MaterialColor::_internal_has_strength() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MaterialColor::has_strength() const {
  return _internal_has_strength();
}
inline void MaterialColor::clear_strength() {
  _impl_.strength_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float MaterialColor::_internal_strength() const {
  return _impl_.strength_;
}
inline float MaterialColor::strength() const {
  // @@protoc_insertion_point(field_get:KuplungApp.MaterialColor.strength)
  return _internal_strength();
}
inline void MaterialColor::_internal_set_strength(float value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.strength_ = value;
}
inline void MaterialColor::set_strength(float value) {
  _internal_set_strength(value);
  // @@protoc_insertion_point(field_set:KuplungApp.MaterialColor.strength)
}

// required .KuplungApp.Vec3 color = 4;
inline bool MaterialColor::_internal_has_color() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.color_ != nullptr);
  return value;
}
inline bool MaterialColor::has_color() const {
  return _internal_has_color();
}
inline void MaterialColor::clear_color() {
  if (_impl_.color_ != nullptr) _impl_.color_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::KuplungApp::Vec3& MaterialColor::_internal_color() const {
  const ::KuplungApp::Vec3* p = _impl_.color_;
  return p != nullptr ? *p : reinterpret_cast<const ::KuplungApp::Vec3&>(
      ::KuplungApp::_Vec3_default_instance_);
}
inline const ::KuplungApp::Vec3& MaterialColor::color() const {
  // @@protoc_insertion_point(field_get:KuplungApp.MaterialColor.color)
  return _internal_color();
}
inline void MaterialColor::unsafe_arena_set_allocated_color(
    ::KuplungApp::Vec3* color) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.color_);
  }
  _impl_.color_ = color;
  if (color) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KuplungApp.MaterialColor.color)
}
inline ::KuplungApp::Vec3* MaterialColor::release_color() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::KuplungApp::Vec3* temp = _impl_.color_;
  _impl_.color_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::KuplungApp::Vec3* MaterialColor::unsafe_arena_release_color() {
  // @@protoc_insertion_point(field_release:KuplungApp.MaterialColor.color)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::KuplungApp::Vec3* temp = _impl_.color_;
  _impl_.color_ = nullptr;
  return temp;
}
inline ::KuplungApp::Vec3* MaterialColor::_internal_mutable_color() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.color_ == nullptr) {
    auto* p = CreateMaybeMessage<::KuplungApp::Vec3>(GetArenaForAllocation());
    _impl_.color_ = p;
  }
  return _impl_.color_;
}
inline ::KuplungApp::Vec3* MaterialColor::mutable_color() {
  ::KuplungApp::Vec3* _msg = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:KuplungApp.MaterialColor.color)
  return _msg;
}
inline void MaterialColor::set_allocated_color(::KuplungApp::Vec3* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.color_;
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(color);
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.color_ = color;
  // @@protoc_insertion_point(field_set_allocated:KuplungApp.MaterialColor.color)
}

// -------------------------------------------------------------------

// MeshMaterialTextureImage

// required string Filename = 1;
inline bool MeshMaterialTextureImage::_internal_has_filename() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MeshMaterialTextureImage::has_filename() const {
  return _internal_has_filename();
}
inline void MeshMaterialTextureImage::clear_filename() {
  _impl_.filename_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MeshMaterialTextureImage::filename() const {
  // @@protoc_insertion_point(field_get:KuplungApp.MeshMaterialTextureImage.Filename)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MeshMaterialTextureImage::set_filename(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.filename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:KuplungApp.MeshMaterialTextureImage.Filename)
}
inline std::string* MeshMaterialTextureImage::mutable_filename() {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:KuplungApp.MeshMaterialTextureImage.Filename)
  return _s;
}
inline const std::string& MeshMaterialTextureImage::_internal_filename() const {
  return _impl_.filename_.Get();
}
inline void MeshMaterialTextureImage::_internal_set_filename(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.filename_.Set(value, GetArenaForAllocation());
}
inline std::string* MeshMaterialTextureImage::_internal_mutable_filename() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.filename_.Mutable(GetArenaForAllocation());
}
inline std::string* MeshMaterialTextureImage::release_filename() {
  // @@protoc_insertion_point(field_release:KuplungApp.MeshMaterialTextureImage.Filename)
  if (!_internal_has_filename()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.filename_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MeshMaterialTextureImage::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.filename_.SetAllocated(filename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KuplungApp.MeshMaterialTextureImage.Filename)
}

// required string Image = 2;
inline bool MeshMaterialTextureImage::_internal_has_image() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MeshMaterialTextureImage::has_image() const {
  return _internal_has_image();
}
inline void MeshMaterialTextureImage::clear_image() {
  _impl_.image_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MeshMaterialTextureImage::image() const {
  // @@protoc_insertion_point(field_get:KuplungApp.MeshMaterialTextureImage.Image)
  return _internal_image();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MeshMaterialTextureImage::set_image(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.image_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:KuplungApp.MeshMaterialTextureImage.Image)
}
inline std::string* MeshMaterialTextureImage::mutable_image() {
  std::string* _s = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:KuplungApp.MeshMaterialTextureImage.Image)
  return _s;
}
inline const std::string& MeshMaterialTextureImage::_internal_image() const {
  return _impl_.image_.Get();
}
inline void MeshMaterialTextureImage::_internal_set_image(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.image_.Set(value, GetArenaForAllocation());
}
inline std::string* MeshMaterialTextureImage::_internal_mutable_image() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.image_.Mutable(GetArenaForAllocation());
}
inline std::string* MeshMaterialTextureImage::release_image() {
  // @@protoc_insertion_point(field_release:KuplungApp.MeshMaterialTextureImage.Image)
  if (!_internal_has_image()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.image_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.image_.IsDefault()) {
    _impl_.image_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MeshMaterialTextureImage::set_allocated_image(std::string* image) {
  if (image != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.image_.SetAllocated(image, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.image_.IsDefault()) {
    _impl_.image_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KuplungApp.MeshMaterialTextureImage.Image)
}

// required int32 Width = 3;
inline bool MeshMaterialTextureImage::_internal_has_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MeshMaterialTextureImage::has_width() const {
  return _internal_has_width();
}
inline void MeshMaterialTextureImage::clear_width() {
  _impl_.width_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t MeshMaterialTextureImage::_internal_width() const {
  return _impl_.width_;
}
inline int32_t MeshMaterialTextureImage::width() const {
  // @@protoc_insertion_point(field_get:KuplungApp.MeshMaterialTextureImage.Width)
  return _internal_width();
}
inline void MeshMaterialTextureImage::_internal_set_width(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.width_ = value;
}
inline void MeshMaterialTextureImage::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:KuplungApp.MeshMaterialTextureImage.Width)
}

// required int32 Height = 4;
inline bool MeshMaterialTextureImage::_internal_has_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MeshMaterialTextureImage::has_height() const {
  return _internal_has_height();
}
inline void MeshMaterialTextureImage::clear_height() {
  _impl_.height_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t MeshMaterialTextureImage::_internal_height() const {
  return _impl_.height_;
}
inline int32_t MeshMaterialTextureImage::height() const {
  // @@protoc_insertion_point(field_get:KuplungApp.MeshMaterialTextureImage.Height)
  return _internal_height();
}
inline void MeshMaterialTextureImage::_internal_set_height(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.height_ = value;
}
inline void MeshMaterialTextureImage::set_height(int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:KuplungApp.MeshMaterialTextureImage.Height)
}

// required bool UseTexture = 5;
inline bool MeshMaterialTextureImage::_internal_has_usetexture() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MeshMaterialTextureImage::has_usetexture() const {
  return _internal_has_usetexture();
}
inline void MeshMaterialTextureImage::clear_usetexture() {
  _impl_.usetexture_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool MeshMaterialTextureImage::_internal_usetexture() const {
  return _impl_.usetexture_;
}
inline bool MeshMaterialTextureImage::usetexture() const {
  // @@protoc_insertion_point(field_get:KuplungApp.MeshMaterialTextureImage.UseTexture)
  return _internal_usetexture();
}
inline void MeshMaterialTextureImage::_internal_set_usetexture(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.usetexture_ = value;
}
inline void MeshMaterialTextureImage::set_usetexture(bool value) {
  _internal_set_usetexture(value);
  // @@protoc_insertion_point(field_set:KuplungApp.MeshMaterialTextureImage.UseTexture)
}

// repeated string Commands = 6;
inline int MeshMaterialTextureImage::_internal_commands_size() const {
  return _impl_.commands_.size();
}
inline int MeshMaterialTextureImage::commands_size() const {
  return _internal_commands_size();
}
inline void MeshMaterialTextureImage::clear_commands() {
  _impl_.commands_.Clear();
}
inline std::string* MeshMaterialTextureImage::add_commands() {
  std::string* _s = _internal_add_commands();
  // @@protoc_insertion_point(field_add_mutable:KuplungApp.MeshMaterialTextureImage.Commands)
  return _s;
}
inline const std::string& MeshMaterialTextureImage::_internal_commands(int index) const {
  return _impl_.commands_.Get(index);
}
inline const std::string& MeshMaterialTextureImage::commands(int index) const {
  // @@protoc_insertion_point(field_get:KuplungApp.MeshMaterialTextureImage.Commands)
  return _internal_commands(index);
}
inline std::string* MeshMaterialTextureImage::mutable_commands(int index) {
  // @@protoc_insertion_point(field_mutable:KuplungApp.MeshMaterialTextureImage.Commands)
  return _impl_.commands_.Mutable(index);
}
inline void MeshMaterialTextureImage::set_commands(int index, const std::string& value) {
  _impl_.commands_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:KuplungApp.MeshMaterialTextureImage.Commands)
}
inline void MeshMaterialTextureImage::set_commands(int index, std::string&& value) {
  _impl_.commands_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:KuplungApp.MeshMaterialTextureImage.Commands)
}
inline void MeshMaterialTextureImage::set_commands(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.commands_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:KuplungApp.MeshMaterialTextureImage.Commands)
}
inline void MeshMaterialTextureImage::set_commands(int index, const char* value, size_t size) {
  _impl_.commands_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KuplungApp.MeshMaterialTextureImage.Commands)
}
inline std::string* MeshMaterialTextureImage::_internal_add_commands() {
  return _impl_.commands_.Add();
}
inline void MeshMaterialTextureImage::add_commands(const std::string& value) {
  _impl_.commands_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:KuplungApp.MeshMaterialTextureImage.Commands)
}
inline void MeshMaterialTextureImage::add_commands(std::string&& value) {
  _impl_.commands_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:KuplungApp.MeshMaterialTextureImage.Commands)
}
inline void MeshMaterialTextureImage::add_commands(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.commands_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:KuplungApp.MeshMaterialTextureImage.Commands)
}
inline void MeshMaterialTextureImage::add_commands(const char* value, size_t size) {
  _impl_.commands_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:KuplungApp.MeshMaterialTextureImage.Commands)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MeshMaterialTextureImage::commands() const {
  // @@protoc_insertion_point(field_list:KuplungApp.MeshMaterialTextureImage.Commands)
  return _impl_.commands_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MeshMaterialTextureImage::mutable_commands() {
  // @@protoc_insertion_point(field_mutable_list:KuplungApp.MeshMaterialTextureImage.Commands)
  return &_impl_.commands_;
}

// -------------------------------------------------------------------

// MeshModelMaterial

// required int32 MaterialID = 1;
inline bool MeshModelMaterial::_internal_has_materialid() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool MeshModelMaterial::has_materialid() const {
  return _internal_has_materialid();
}
inline void MeshModelMaterial::clear_materialid() {
  _impl_.materialid_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline int32_t MeshModelMaterial::_internal_materialid() const {
  return _impl_.materialid_;
}
inline int32_t MeshModelMaterial::materialid() const {
  // @@protoc_insertion_point(field_get:KuplungApp.MeshModelMaterial.MaterialID)
  return _internal_materialid();
}
inline void MeshModelMaterial::_internal_set_materialid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.materialid_ = value;
}
inline void MeshModelMaterial::set_materialid(int32_t value) {
  _internal_set_materialid(value);
  // @@protoc_insertion_point(field_set:KuplungApp.MeshModelMaterial.MaterialID)
}

// required string MaterialTitle = 2;
inline bool MeshModelMaterial::_internal_has_materialtitle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MeshModelMaterial::has_materialtitle() const {
  return _internal_has_materialtitle();
}
inline void MeshModelMaterial::clear_materialtitle() {
  _impl_.materialtitle_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MeshModelMaterial::materialtitle() const {
  // @@protoc_insertion_point(field_get:KuplungApp.MeshModelMaterial.MaterialTitle)
  return _internal_materialtitle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MeshModelMaterial::set_materialtitle(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.materialtitle_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:KuplungApp.MeshModelMaterial.MaterialTitle)
}
inline std::string* MeshModelMaterial::mutable_materialtitle() {
  std::string* _s = _internal_mutable_materialtitle();
  // @@protoc_insertion_point(field_mutable:KuplungApp.MeshModelMaterial.MaterialTitle)
  return _s;
}
inline const std::string& MeshModelMaterial::_internal_materialtitle() const {
  return _impl_.materialtitle_.Get();
}
inline void MeshModelMaterial::_internal_set_materialtitle(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.materialtitle_.Set(value, GetArenaForAllocation());
}
inline std::string* MeshModelMaterial::_internal_mutable_materialtitle() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.materialtitle_.Mutable(GetArenaForAllocation());
}
inline std::string* MeshModelMaterial::release_materialtitle() {
  // @@protoc_insertion_point(field_release:KuplungApp.MeshModelMaterial.MaterialTitle)
  if (!_internal_has_materialtitle()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.materialtitle_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.materialtitle_.IsDefault()) {
    _impl_.materialtitle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MeshModelMaterial::set_allocated_materialtitle(std::string* materialtitle) {
  if (materialtitle != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.materialtitle_.SetAllocated(materialtitle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.materialtitle_.IsDefault()) {
    _impl_.materialtitle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KuplungApp.MeshModelMaterial.MaterialTitle)
}

// required .KuplungApp.Vec3 AmbientColor = 3;
inline bool MeshModelMaterial::_internal_has_ambientcolor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ambientcolor_ != nullptr);
  return value;
}
inline bool MeshModelMaterial::has_ambientcolor() const {
  return _internal_has_ambientcolor();
}
inline void MeshModelMaterial::clear_ambientcolor() {
  if (_impl_.ambientcolor_ != nullptr) _impl_.ambientcolor_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::KuplungApp::Vec3& MeshModelMaterial::_internal_ambientcolor() const {
  const ::KuplungApp::Vec3* p = _impl_.ambientcolor_;
  return p != nullptr ? *p : reinterpret_cast<const ::KuplungApp::Vec3&>(
      ::KuplungApp::_Vec3_default_instance_);
}
inline const ::KuplungApp::Vec3& MeshModelMaterial::ambientcolor() const {
  // @@protoc_insertion_point(field_get:KuplungApp.MeshModelMaterial.AmbientColor)
  return _internal_ambientcolor();
}
inline void MeshModelMaterial::unsafe_arena_set_allocated_ambientcolor(
    ::KuplungApp::Vec3* ambientcolor) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ambientcolor_);
  }
  _impl_.ambientcolor_ = ambientcolor;
  if (ambientcolor) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KuplungApp.MeshModelMaterial.AmbientColor)
}
inline ::KuplungApp::Vec3* MeshModelMaterial::release_ambientcolor() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::KuplungApp::Vec3* temp = _impl_.ambientcolor_;
  _impl_.ambientcolor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::KuplungApp::Vec3* MeshModelMaterial::unsafe_arena_release_ambientcolor() {
  // @@protoc_insertion_point(field_release:KuplungApp.MeshModelMaterial.AmbientColor)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::KuplungApp::Vec3* temp = _impl_.ambientcolor_;
  _impl_.ambientcolor_ = nullptr;
  return temp;
}
inline ::KuplungApp::Vec3* MeshModelMaterial::_internal_mutable_ambientcolor() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.ambientcolor_ == nullptr) {
    auto* p = CreateMaybeMessage<::KuplungApp::Vec3>(GetArenaForAllocation());
    _impl_.ambientcolor_ = p;
  }
  return _impl_.ambientcolor_;
}
inline ::KuplungApp::Vec3* MeshModelMaterial::mutable_ambientcolor() {
  ::KuplungApp::Vec3* _msg = _internal_mutable_ambientcolor();
  // @@protoc_insertion_point(field_mutable:KuplungApp.MeshModelMaterial.AmbientColor)
  return _msg;
}
inline void MeshModelMaterial::set_allocated_ambientcolor(::KuplungApp::Vec3* ambientcolor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ambientcolor_;
  }
  if (ambientcolor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ambientcolor);
    if (message_arena != submessage_arena) {
      ambientcolor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ambientcolor, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.ambientcolor_ = ambientcolor;
  // @@protoc_insertion_point(field_set_allocated:KuplungApp.MeshModelMaterial.AmbientColor)
}

// required .KuplungApp.Vec3 DiffuseColor = 4;
inline bool MeshModelMaterial::_internal_has_diffusecolor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.diffusecolor_ != nullptr);
  return value;
}
inline bool MeshModelMaterial::has_diffusecolor() const {
  return _internal_has_diffusecolor();
}
inline void MeshModelMaterial::clear_diffusecolor() {
  if (_impl_.diffusecolor_ != nullptr) _impl_.diffusecolor_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::KuplungApp::Vec3& MeshModelMaterial::_internal_diffusecolor() const {
  const ::KuplungApp::Vec3* p = _impl_.diffusecolor_;
  return p != nullptr ? *p : reinterpret_cast<const ::KuplungApp::Vec3&>(
      ::KuplungApp::_Vec3_default_instance_);
}
inline const ::KuplungApp::Vec3& MeshModelMaterial::diffusecolor() const {
  // @@protoc_insertion_point(field_get:KuplungApp.MeshModelMaterial.DiffuseColor)
  return _internal_diffusecolor();
}
inline void MeshModelMaterial::unsafe_arena_set_allocated_diffusecolor(
    ::KuplungApp::Vec3* diffusecolor) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.diffusecolor_);
  }
  _impl_.diffusecolor_ = diffusecolor;
  if (diffusecolor) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KuplungApp.MeshModelMaterial.DiffuseColor)
}
inline ::KuplungApp::Vec3* MeshModelMaterial::release_diffusecolor() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::KuplungApp::Vec3* temp = _impl_.diffusecolor_;
  _impl_.diffusecolor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::KuplungApp::Vec3* MeshModelMaterial::unsafe_arena_release_diffusecolor() {
  // @@protoc_insertion_point(field_release:KuplungApp.MeshModelMaterial.DiffuseColor)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::KuplungApp::Vec3* temp = _impl_.diffusecolor_;
  _impl_.diffusecolor_ = nullptr;
  return temp;
}
inline ::KuplungApp::Vec3* MeshModelMaterial::_internal_mutable_diffusecolor() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.diffusecolor_ == nullptr) {
    auto* p = CreateMaybeMessage<::KuplungApp::Vec3>(GetArenaForAllocation());
    _impl_.diffusecolor_ = p;
  }
  return _impl_.diffusecolor_;
}
inline ::KuplungApp::Vec3* MeshModelMaterial::mutable_diffusecolor() {
  ::KuplungApp::Vec3* _msg = _internal_mutable_diffusecolor();
  // @@protoc_insertion_point(field_mutable:KuplungApp.MeshModelMaterial.DiffuseColor)
  return _msg;
}
inline void MeshModelMaterial::set_allocated_diffusecolor(::KuplungApp::Vec3* diffusecolor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.diffusecolor_;
  }
  if (diffusecolor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(diffusecolor);
    if (message_arena != submessage_arena) {
      diffusecolor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, diffusecolor, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.diffusecolor_ = diffusecolor;
  // @@protoc_insertion_point(field_set_allocated:KuplungApp.MeshModelMaterial.DiffuseColor)
}

// required .KuplungApp.Vec3 SpecularColor = 5;
inline bool MeshModelMaterial::_internal_has_specularcolor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.specularcolor_ != nullptr);
  return value;
}
inline bool MeshModelMaterial::has_specularcolor() const {
  return _internal_has_specularcolor();
}
inline void MeshModelMaterial::clear_specularcolor() {
  if (_impl_.specularcolor_ != nullptr) _impl_.specularcolor_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::KuplungApp::Vec3& MeshModelMaterial::_internal_specularcolor() const {
  const ::KuplungApp::Vec3* p = _impl_.specularcolor_;
  return p != nullptr ? *p : reinterpret_cast<const ::KuplungApp::Vec3&>(
      ::KuplungApp::_Vec3_default_instance_);
}
inline const ::KuplungApp::Vec3& MeshModelMaterial::specularcolor() const {
  // @@protoc_insertion_point(field_get:KuplungApp.MeshModelMaterial.SpecularColor)
  return _internal_specularcolor();
}
inline void MeshModelMaterial::unsafe_arena_set_allocated_specularcolor(
    ::KuplungApp::Vec3* specularcolor) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.specularcolor_);
  }
  _impl_.specularcolor_ = specularcolor;
  if (specularcolor) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KuplungApp.MeshModelMaterial.SpecularColor)
}
inline ::KuplungApp::Vec3* MeshModelMaterial::release_specularcolor() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::KuplungApp::Vec3* temp = _impl_.specularcolor_;
  _impl_.specularcolor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::KuplungApp::Vec3* MeshModelMaterial::unsafe_arena_release_specularcolor() {
  // @@protoc_insertion_point(field_release:KuplungApp.MeshModelMaterial.SpecularColor)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::KuplungApp::Vec3* temp = _impl_.specularcolor_;
  _impl_.specularcolor_ = nullptr;
  return temp;
}
inline ::KuplungApp::Vec3* MeshModelMaterial::_internal_mutable_specularcolor() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.specularcolor_ == nullptr) {
    auto* p = CreateMaybeMessage<::KuplungApp::Vec3>(GetArenaForAllocation());
    _impl_.specularcolor_ = p;
  }
  return _impl_.specularcolor_;
}
inline ::KuplungApp::Vec3* MeshModelMaterial::mutable_specularcolor() {
  ::KuplungApp::Vec3* _msg = _internal_mutable_specularcolor();
  // @@protoc_insertion_point(field_mutable:KuplungApp.MeshModelMaterial.SpecularColor)
  return _msg;
}
inline void MeshModelMaterial::set_allocated_specularcolor(::KuplungApp::Vec3* specularcolor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.specularcolor_;
  }
  if (specularcolor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(specularcolor);
    if (message_arena != submessage_arena) {
      specularcolor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, specularcolor, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.specularcolor_ = specularcolor;
  // @@protoc_insertion_point(field_set_allocated:KuplungApp.MeshModelMaterial.SpecularColor)
}

// required .KuplungApp.Vec3 EmissionColor = 6;
inline bool MeshModelMaterial::_internal_has_emissioncolor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.emissioncolor_ != nullptr);
  return value;
}
inline bool MeshModelMaterial::has_emissioncolor() const {
  return _internal_has_emissioncolor();
}
inline void MeshModelMaterial::clear_emissioncolor() {
  if (_impl_.emissioncolor_ != nullptr) _impl_.emissioncolor_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::KuplungApp::Vec3& MeshModelMaterial::_internal_emissioncolor() const {
  const ::KuplungApp::Vec3* p = _impl_.emissioncolor_;
  return p != nullptr ? *p : reinterpret_cast<const ::KuplungApp::Vec3&>(
      ::KuplungApp::_Vec3_default_instance_);
}
inline const ::KuplungApp::Vec3& MeshModelMaterial::emissioncolor() const {
  // @@protoc_insertion_point(field_get:KuplungApp.MeshModelMaterial.EmissionColor)
  return _internal_emissioncolor();
}
inline void MeshModelMaterial::unsafe_arena_set_allocated_emissioncolor(
    ::KuplungApp::Vec3* emissioncolor) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.emissioncolor_);
  }
  _impl_.emissioncolor_ = emissioncolor;
  if (emissioncolor) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KuplungApp.MeshModelMaterial.EmissionColor)
}
inline ::KuplungApp::Vec3* MeshModelMaterial::release_emissioncolor() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::KuplungApp::Vec3* temp = _impl_.emissioncolor_;
  _impl_.emissioncolor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::KuplungApp::Vec3* MeshModelMaterial::unsafe_arena_release_emissioncolor() {
  // @@protoc_insertion_point(field_release:KuplungApp.MeshModelMaterial.EmissionColor)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::KuplungApp::Vec3* temp = _impl_.emissioncolor_;
  _impl_.emissioncolor_ = nullptr;
  return temp;
}
inline ::KuplungApp::Vec3* MeshModelMaterial::_internal_mutable_emissioncolor() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.emissioncolor_ == nullptr) {
    auto* p = CreateMaybeMessage<::KuplungApp::Vec3>(GetArenaForAllocation());
    _impl_.emissioncolor_ = p;
  }
  return _impl_.emissioncolor_;
}
inline ::KuplungApp::Vec3* MeshModelMaterial::mutable_emissioncolor() {
  ::KuplungApp::Vec3* _msg = _internal_mutable_emissioncolor();
  // @@protoc_insertion_point(field_mutable:KuplungApp.MeshModelMaterial.EmissionColor)
  return _msg;
}
inline void MeshModelMaterial::set_allocated_emissioncolor(::KuplungApp::Vec3* emissioncolor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.emissioncolor_;
  }
  if (emissioncolor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(emissioncolor);
    if (message_arena != submessage_arena) {
      emissioncolor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, emissioncolor, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.emissioncolor_ = emissioncolor;
  // @@protoc_insertion_point(field_set_allocated:KuplungApp.MeshModelMaterial.EmissionColor)
}

// required float SpecularExp = 7;
inline bool MeshModelMaterial::_internal_has_specularexp() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool MeshModelMaterial::has_specularexp() const {
  return _internal_has_specularexp();
}
inline void MeshModelMaterial::clear_specularexp() {
  _impl_.specularexp_ = 0;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline float MeshModelMaterial::_internal_specularexp() const {
  return _impl_.specularexp_;
}
inline float MeshModelMaterial::specularexp() const {
  // @@protoc_insertion_point(field_get:KuplungApp.MeshModelMaterial.SpecularExp)
  return _internal_specularexp();
}
inline void MeshModelMaterial::_internal_set_specularexp(float value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.specularexp_ = value;
}
inline void MeshModelMaterial::set_specularexp(float value) {
  _internal_set_specularexp(value);
  // @@protoc_insertion_point(field_set:KuplungApp.MeshModelMaterial.SpecularExp)
}

// required float Transparency = 8;
inline bool MeshModelMaterial::_internal_has_transparency() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool MeshModelMaterial::has_transparency() const {
  return _internal_has_transparency();
}
inline void MeshModelMaterial::clear_transparency() {
  _impl_.transparency_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline float MeshModelMaterial::_internal_transparency() const {
  return _impl_.transparency_;
}
inline float MeshModelMaterial::transparency() const {
  // @@protoc_insertion_point(field_get:KuplungApp.MeshModelMaterial.Transparency)
  return _internal_transparency();
}
inline void MeshModelMaterial::_internal_set_transparency(float value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.transparency_ = value;
}
inline void MeshModelMaterial::set_transparency(float value) {
  _internal_set_transparency(value);
  // @@protoc_insertion_point(field_set:KuplungApp.MeshModelMaterial.Transparency)
}

// required fixed32 IlluminationMode = 9;
inline bool MeshModelMaterial::_internal_has_illuminationmode() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool MeshModelMaterial::has_illuminationmode() const {
  return _internal_has_illuminationmode();
}
inline void MeshModelMaterial::clear_illuminationmode() {
  _impl_.illuminationmode_ = 0u;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline uint32_t MeshModelMaterial::_internal_illuminationmode() const {
  return _impl_.illuminationmode_;
}
inline uint32_t MeshModelMaterial::illuminationmode() const {
  // @@protoc_insertion_point(field_get:KuplungApp.MeshModelMaterial.IlluminationMode)
  return _internal_illuminationmode();
}
inline void MeshModelMaterial::_internal_set_illuminationmode(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.illuminationmode_ = value;
}
inline void MeshModelMaterial::set_illuminationmode(uint32_t value) {
  _internal_set_illuminationmode(value);
  // @@protoc_insertion_point(field_set:KuplungApp.MeshModelMaterial.IlluminationMode)
}

// required float OpticalDensity = 10;
inline bool MeshModelMaterial::_internal_has_opticaldensity() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool MeshModelMaterial::has_opticaldensity() const {
  return _internal_has_opticaldensity();
}
inline void MeshModelMaterial::clear_opticaldensity() {
  _impl_.opticaldensity_ = 0;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline float MeshModelMaterial::_internal_opticaldensity() const {
  return _impl_.opticaldensity_;
}
inline float MeshModelMaterial::opticaldensity() const {
  // @@protoc_insertion_point(field_get:KuplungApp.MeshModelMaterial.OpticalDensity)
  return _internal_opticaldensity();
}
inline void MeshModelMaterial::_internal_set_opticaldensity(float value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.opticaldensity_ = value;
}
inline void MeshModelMaterial::set_opticaldensity(float value) {
  _internal_set_opticaldensity(value);
  // @@protoc_insertion_point(field_set:KuplungApp.MeshModelMaterial.OpticalDensity)
}

// required .KuplungApp.MeshMaterialTextureImage TextureAmbient = 11;
inline bool MeshModelMaterial::_internal_has_textureambient() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.textureambient_ != nullptr);
  return value;
}
inline bool MeshModelMaterial::has_textureambient() const {
  return _internal_has_textureambient();
}
inline void MeshModelMaterial::clear_textureambient() {
  if (_impl_.textureambient_ != nullptr) _impl_.textureambient_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::KuplungApp::MeshMaterialTextureImage& MeshModelMaterial::_internal_textureambient() const {
  const ::KuplungApp::MeshMaterialTextureImage* p = _impl_.textureambient_;
  return p != nullptr ? *p : reinterpret_cast<const ::KuplungApp::MeshMaterialTextureImage&>(
      ::KuplungApp::_MeshMaterialTextureImage_default_instance_);
}
inline const ::KuplungApp::MeshMaterialTextureImage& MeshModelMaterial::textureambient() const {
  // @@protoc_insertion_point(field_get:KuplungApp.MeshModelMaterial.TextureAmbient)
  return _internal_textureambient();
}
inline void MeshModelMaterial::unsafe_arena_set_allocated_textureambient(
    ::KuplungApp::MeshMaterialTextureImage* textureambient) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.textureambient_);
  }
  _impl_.textureambient_ = textureambient;
  if (textureambient) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KuplungApp.MeshModelMaterial.TextureAmbient)
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::release_textureambient() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::KuplungApp::MeshMaterialTextureImage* temp = _impl_.textureambient_;
  _impl_.textureambient_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::unsafe_arena_release_textureambient() {
  // @@protoc_insertion_point(field_release:KuplungApp.MeshModelMaterial.TextureAmbient)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::KuplungApp::MeshMaterialTextureImage* temp = _impl_.textureambient_;
  _impl_.textureambient_ = nullptr;
  return temp;
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::_internal_mutable_textureambient() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.textureambient_ == nullptr) {
    auto* p = CreateMaybeMessage<::KuplungApp::MeshMaterialTextureImage>(GetArenaForAllocation());
    _impl_.textureambient_ = p;
  }
  return _impl_.textureambient_;
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::mutable_textureambient() {
  ::KuplungApp::MeshMaterialTextureImage* _msg = _internal_mutable_textureambient();
  // @@protoc_insertion_point(field_mutable:KuplungApp.MeshModelMaterial.TextureAmbient)
  return _msg;
}
inline void MeshModelMaterial::set_allocated_textureambient(::KuplungApp::MeshMaterialTextureImage* textureambient) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.textureambient_;
  }
  if (textureambient) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(textureambient);
    if (message_arena != submessage_arena) {
      textureambient = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, textureambient, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.textureambient_ = textureambient;
  // @@protoc_insertion_point(field_set_allocated:KuplungApp.MeshModelMaterial.TextureAmbient)
}

// required .KuplungApp.MeshMaterialTextureImage TextureDiffuse = 12;
inline bool MeshModelMaterial::_internal_has_texturediffuse() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.texturediffuse_ != nullptr);
  return value;
}
inline bool MeshModelMaterial::has_texturediffuse() const {
  return _internal_has_texturediffuse();
}
inline void MeshModelMaterial::clear_texturediffuse() {
  if (_impl_.texturediffuse_ != nullptr) _impl_.texturediffuse_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::KuplungApp::MeshMaterialTextureImage& MeshModelMaterial::_internal_texturediffuse() const {
  const ::KuplungApp::MeshMaterialTextureImage* p = _impl_.texturediffuse_;
  return p != nullptr ? *p : reinterpret_cast<const ::KuplungApp::MeshMaterialTextureImage&>(
      ::KuplungApp::_MeshMaterialTextureImage_default_instance_);
}
inline const ::KuplungApp::MeshMaterialTextureImage& MeshModelMaterial::texturediffuse() const {
  // @@protoc_insertion_point(field_get:KuplungApp.MeshModelMaterial.TextureDiffuse)
  return _internal_texturediffuse();
}
inline void MeshModelMaterial::unsafe_arena_set_allocated_texturediffuse(
    ::KuplungApp::MeshMaterialTextureImage* texturediffuse) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.texturediffuse_);
  }
  _impl_.texturediffuse_ = texturediffuse;
  if (texturediffuse) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KuplungApp.MeshModelMaterial.TextureDiffuse)
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::release_texturediffuse() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::KuplungApp::MeshMaterialTextureImage* temp = _impl_.texturediffuse_;
  _impl_.texturediffuse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::unsafe_arena_release_texturediffuse() {
  // @@protoc_insertion_point(field_release:KuplungApp.MeshModelMaterial.TextureDiffuse)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::KuplungApp::MeshMaterialTextureImage* temp = _impl_.texturediffuse_;
  _impl_.texturediffuse_ = nullptr;
  return temp;
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::_internal_mutable_texturediffuse() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.texturediffuse_ == nullptr) {
    auto* p = CreateMaybeMessage<::KuplungApp::MeshMaterialTextureImage>(GetArenaForAllocation());
    _impl_.texturediffuse_ = p;
  }
  return _impl_.texturediffuse_;
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::mutable_texturediffuse() {
  ::KuplungApp::MeshMaterialTextureImage* _msg = _internal_mutable_texturediffuse();
  // @@protoc_insertion_point(field_mutable:KuplungApp.MeshModelMaterial.TextureDiffuse)
  return _msg;
}
inline void MeshModelMaterial::set_allocated_texturediffuse(::KuplungApp::MeshMaterialTextureImage* texturediffuse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.texturediffuse_;
  }
  if (texturediffuse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(texturediffuse);
    if (message_arena != submessage_arena) {
      texturediffuse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, texturediffuse, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.texturediffuse_ = texturediffuse;
  // @@protoc_insertion_point(field_set_allocated:KuplungApp.MeshModelMaterial.TextureDiffuse)
}

// required .KuplungApp.MeshMaterialTextureImage TextureSpecular = 13;
inline bool MeshModelMaterial::_internal_has_texturespecular() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.texturespecular_ != nullptr);
  return value;
}
inline bool MeshModelMaterial::has_texturespecular() const {
  return _internal_has_texturespecular();
}
inline void MeshModelMaterial::clear_texturespecular() {
  if (_impl_.texturespecular_ != nullptr) _impl_.texturespecular_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::KuplungApp::MeshMaterialTextureImage& MeshModelMaterial::_internal_texturespecular() const {
  const ::KuplungApp::MeshMaterialTextureImage* p = _impl_.texturespecular_;
  return p != nullptr ? *p : reinterpret_cast<const ::KuplungApp::MeshMaterialTextureImage&>(
      ::KuplungApp::_MeshMaterialTextureImage_default_instance_);
}
inline const ::KuplungApp::MeshMaterialTextureImage& MeshModelMaterial::texturespecular() const {
  // @@protoc_insertion_point(field_get:KuplungApp.MeshModelMaterial.TextureSpecular)
  return _internal_texturespecular();
}
inline void MeshModelMaterial::unsafe_arena_set_allocated_texturespecular(
    ::KuplungApp::MeshMaterialTextureImage* texturespecular) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.texturespecular_);
  }
  _impl_.texturespecular_ = texturespecular;
  if (texturespecular) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KuplungApp.MeshModelMaterial.TextureSpecular)
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::release_texturespecular() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::KuplungApp::MeshMaterialTextureImage* temp = _impl_.texturespecular_;
  _impl_.texturespecular_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::unsafe_arena_release_texturespecular() {
  // @@protoc_insertion_point(field_release:KuplungApp.MeshModelMaterial.TextureSpecular)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::KuplungApp::MeshMaterialTextureImage* temp = _impl_.texturespecular_;
  _impl_.texturespecular_ = nullptr;
  return temp;
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::_internal_mutable_texturespecular() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.texturespecular_ == nullptr) {
    auto* p = CreateMaybeMessage<::KuplungApp::MeshMaterialTextureImage>(GetArenaForAllocation());
    _impl_.texturespecular_ = p;
  }
  return _impl_.texturespecular_;
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::mutable_texturespecular() {
  ::KuplungApp::MeshMaterialTextureImage* _msg = _internal_mutable_texturespecular();
  // @@protoc_insertion_point(field_mutable:KuplungApp.MeshModelMaterial.TextureSpecular)
  return _msg;
}
inline void MeshModelMaterial::set_allocated_texturespecular(::KuplungApp::MeshMaterialTextureImage* texturespecular) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.texturespecular_;
  }
  if (texturespecular) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(texturespecular);
    if (message_arena != submessage_arena) {
      texturespecular = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, texturespecular, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.texturespecular_ = texturespecular;
  // @@protoc_insertion_point(field_set_allocated:KuplungApp.MeshModelMaterial.TextureSpecular)
}

// required .KuplungApp.MeshMaterialTextureImage TextureSpecularExp = 14;
inline bool MeshModelMaterial::_internal_has_texturespecularexp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.texturespecularexp_ != nullptr);
  return value;
}
inline bool MeshModelMaterial::has_texturespecularexp() const {
  return _internal_has_texturespecularexp();
}
inline void MeshModelMaterial::clear_texturespecularexp() {
  if (_impl_.texturespecularexp_ != nullptr) _impl_.texturespecularexp_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::KuplungApp::MeshMaterialTextureImage& MeshModelMaterial::_internal_texturespecularexp() const {
  const ::KuplungApp::MeshMaterialTextureImage* p = _impl_.texturespecularexp_;
  return p != nullptr ? *p : reinterpret_cast<const ::KuplungApp::MeshMaterialTextureImage&>(
      ::KuplungApp::_MeshMaterialTextureImage_default_instance_);
}
inline const ::KuplungApp::MeshMaterialTextureImage& MeshModelMaterial::texturespecularexp() const {
  // @@protoc_insertion_point(field_get:KuplungApp.MeshModelMaterial.TextureSpecularExp)
  return _internal_texturespecularexp();
}
inline void MeshModelMaterial::unsafe_arena_set_allocated_texturespecularexp(
    ::KuplungApp::MeshMaterialTextureImage* texturespecularexp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.texturespecularexp_);
  }
  _impl_.texturespecularexp_ = texturespecularexp;
  if (texturespecularexp) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KuplungApp.MeshModelMaterial.TextureSpecularExp)
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::release_texturespecularexp() {
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::KuplungApp::MeshMaterialTextureImage* temp = _impl_.texturespecularexp_;
  _impl_.texturespecularexp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::unsafe_arena_release_texturespecularexp() {
  // @@protoc_insertion_point(field_release:KuplungApp.MeshModelMaterial.TextureSpecularExp)
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::KuplungApp::MeshMaterialTextureImage* temp = _impl_.texturespecularexp_;
  _impl_.texturespecularexp_ = nullptr;
  return temp;
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::_internal_mutable_texturespecularexp() {
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.texturespecularexp_ == nullptr) {
    auto* p = CreateMaybeMessage<::KuplungApp::MeshMaterialTextureImage>(GetArenaForAllocation());
    _impl_.texturespecularexp_ = p;
  }
  return _impl_.texturespecularexp_;
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::mutable_texturespecularexp() {
  ::KuplungApp::MeshMaterialTextureImage* _msg = _internal_mutable_texturespecularexp();
  // @@protoc_insertion_point(field_mutable:KuplungApp.MeshModelMaterial.TextureSpecularExp)
  return _msg;
}
inline void MeshModelMaterial::set_allocated_texturespecularexp(::KuplungApp::MeshMaterialTextureImage* texturespecularexp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.texturespecularexp_;
  }
  if (texturespecularexp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(texturespecularexp);
    if (message_arena != submessage_arena) {
      texturespecularexp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, texturespecularexp, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.texturespecularexp_ = texturespecularexp;
  // @@protoc_insertion_point(field_set_allocated:KuplungApp.MeshModelMaterial.TextureSpecularExp)
}

// required .KuplungApp.MeshMaterialTextureImage TextureDissolve = 15;
inline bool MeshModelMaterial::_internal_has_texturedissolve() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.texturedissolve_ != nullptr);
  return value;
}
inline bool MeshModelMaterial::has_texturedissolve() const {
  return _internal_has_texturedissolve();
}
inline void MeshModelMaterial::clear_texturedissolve() {
  if (_impl_.texturedissolve_ != nullptr) _impl_.texturedissolve_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::KuplungApp::MeshMaterialTextureImage& MeshModelMaterial::_internal_texturedissolve() const {
  const ::KuplungApp::MeshMaterialTextureImage* p = _impl_.texturedissolve_;
  return p != nullptr ? *p : reinterpret_cast<const ::KuplungApp::MeshMaterialTextureImage&>(
      ::KuplungApp::_MeshMaterialTextureImage_default_instance_);
}
inline const ::KuplungApp::MeshMaterialTextureImage& MeshModelMaterial::texturedissolve() const {
  // @@protoc_insertion_point(field_get:KuplungApp.MeshModelMaterial.TextureDissolve)
  return _internal_texturedissolve();
}
inline void MeshModelMaterial::unsafe_arena_set_allocated_texturedissolve(
    ::KuplungApp::MeshMaterialTextureImage* texturedissolve) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.texturedissolve_);
  }
  _impl_.texturedissolve_ = texturedissolve;
  if (texturedissolve) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KuplungApp.MeshModelMaterial.TextureDissolve)
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::release_texturedissolve() {
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::KuplungApp::MeshMaterialTextureImage* temp = _impl_.texturedissolve_;
  _impl_.texturedissolve_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::unsafe_arena_release_texturedissolve() {
  // @@protoc_insertion_point(field_release:KuplungApp.MeshModelMaterial.TextureDissolve)
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::KuplungApp::MeshMaterialTextureImage* temp = _impl_.texturedissolve_;
  _impl_.texturedissolve_ = nullptr;
  return temp;
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::_internal_mutable_texturedissolve() {
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.texturedissolve_ == nullptr) {
    auto* p = CreateMaybeMessage<::KuplungApp::MeshMaterialTextureImage>(GetArenaForAllocation());
    _impl_.texturedissolve_ = p;
  }
  return _impl_.texturedissolve_;
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::mutable_texturedissolve() {
  ::KuplungApp::MeshMaterialTextureImage* _msg = _internal_mutable_texturedissolve();
  // @@protoc_insertion_point(field_mutable:KuplungApp.MeshModelMaterial.TextureDissolve)
  return _msg;
}
inline void MeshModelMaterial::set_allocated_texturedissolve(::KuplungApp::MeshMaterialTextureImage* texturedissolve) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.texturedissolve_;
  }
  if (texturedissolve) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(texturedissolve);
    if (message_arena != submessage_arena) {
      texturedissolve = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, texturedissolve, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.texturedissolve_ = texturedissolve;
  // @@protoc_insertion_point(field_set_allocated:KuplungApp.MeshModelMaterial.TextureDissolve)
}

// required .KuplungApp.MeshMaterialTextureImage TextureBump = 16;
inline bool MeshModelMaterial::_internal_has_texturebump() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.texturebump_ != nullptr);
  return value;
}
inline bool MeshModelMaterial::has_texturebump() const {
  return _internal_has_texturebump();
}
inline void MeshModelMaterial::clear_texturebump() {
  if (_impl_.texturebump_ != nullptr) _impl_.texturebump_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const ::KuplungApp::MeshMaterialTextureImage& MeshModelMaterial::_internal_texturebump() const {
  const ::KuplungApp::MeshMaterialTextureImage* p = _impl_.texturebump_;
  return p != nullptr ? *p : reinterpret_cast<const ::KuplungApp::MeshMaterialTextureImage&>(
      ::KuplungApp::_MeshMaterialTextureImage_default_instance_);
}
inline const ::KuplungApp::MeshMaterialTextureImage& MeshModelMaterial::texturebump() const {
  // @@protoc_insertion_point(field_get:KuplungApp.MeshModelMaterial.TextureBump)
  return _internal_texturebump();
}
inline void MeshModelMaterial::unsafe_arena_set_allocated_texturebump(
    ::KuplungApp::MeshMaterialTextureImage* texturebump) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.texturebump_);
  }
  _impl_.texturebump_ = texturebump;
  if (texturebump) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KuplungApp.MeshModelMaterial.TextureBump)
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::release_texturebump() {
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::KuplungApp::MeshMaterialTextureImage* temp = _impl_.texturebump_;
  _impl_.texturebump_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::unsafe_arena_release_texturebump() {
  // @@protoc_insertion_point(field_release:KuplungApp.MeshModelMaterial.TextureBump)
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::KuplungApp::MeshMaterialTextureImage* temp = _impl_.texturebump_;
  _impl_.texturebump_ = nullptr;
  return temp;
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::_internal_mutable_texturebump() {
  _impl_._has_bits_[0] |= 0x00000400u;
  if (_impl_.texturebump_ == nullptr) {
    auto* p = CreateMaybeMessage<::KuplungApp::MeshMaterialTextureImage>(GetArenaForAllocation());
    _impl_.texturebump_ = p;
  }
  return _impl_.texturebump_;
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::mutable_texturebump() {
  ::KuplungApp::MeshMaterialTextureImage* _msg = _internal_mutable_texturebump();
  // @@protoc_insertion_point(field_mutable:KuplungApp.MeshModelMaterial.TextureBump)
  return _msg;
}
inline void MeshModelMaterial::set_allocated_texturebump(::KuplungApp::MeshMaterialTextureImage* texturebump) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.texturebump_;
  }
  if (texturebump) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(texturebump);
    if (message_arena != submessage_arena) {
      texturebump = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, texturebump, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.texturebump_ = texturebump;
  // @@protoc_insertion_point(field_set_allocated:KuplungApp.MeshModelMaterial.TextureBump)
}

// required .KuplungApp.MeshMaterialTextureImage TextureDisplacement = 17;
inline bool MeshModelMaterial::_internal_has_texturedisplacement() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.texturedisplacement_ != nullptr);
  return value;
}
inline bool MeshModelMaterial::has_texturedisplacement() const {
  return _internal_has_texturedisplacement();
}
inline void MeshModelMaterial::clear_texturedisplacement() {
  if (_impl_.texturedisplacement_ != nullptr) _impl_.texturedisplacement_->Clear();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const ::KuplungApp::MeshMaterialTextureImage& MeshModelMaterial::_internal_texturedisplacement() const {
  const ::KuplungApp::MeshMaterialTextureImage* p = _impl_.texturedisplacement_;
  return p != nullptr ? *p : reinterpret_cast<const ::KuplungApp::MeshMaterialTextureImage&>(
      ::KuplungApp::_MeshMaterialTextureImage_default_instance_);
}
inline const ::KuplungApp::MeshMaterialTextureImage& MeshModelMaterial::texturedisplacement() const {
  // @@protoc_insertion_point(field_get:KuplungApp.MeshModelMaterial.TextureDisplacement)
  return _internal_texturedisplacement();
}
inline void MeshModelMaterial::unsafe_arena_set_allocated_texturedisplacement(
    ::KuplungApp::MeshMaterialTextureImage* texturedisplacement) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.texturedisplacement_);
  }
  _impl_.texturedisplacement_ = texturedisplacement;
  if (texturedisplacement) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KuplungApp.MeshModelMaterial.TextureDisplacement)
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::release_texturedisplacement() {
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::KuplungApp::MeshMaterialTextureImage* temp = _impl_.texturedisplacement_;
  _impl_.texturedisplacement_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::unsafe_arena_release_texturedisplacement() {
  // @@protoc_insertion_point(field_release:KuplungApp.MeshModelMaterial.TextureDisplacement)
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::KuplungApp::MeshMaterialTextureImage* temp = _impl_.texturedisplacement_;
  _impl_.texturedisplacement_ = nullptr;
  return temp;
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::_internal_mutable_texturedisplacement() {
  _impl_._has_bits_[0] |= 0x00000800u;
  if (_impl_.texturedisplacement_ == nullptr) {
    auto* p = CreateMaybeMessage<::KuplungApp::MeshMaterialTextureImage>(GetArenaForAllocation());
    _impl_.texturedisplacement_ = p;
  }
  return _impl_.texturedisplacement_;
}
inline ::KuplungApp::MeshMaterialTextureImage* MeshModelMaterial::mutable_texturedisplacement() {
  ::KuplungApp::MeshMaterialTextureImage* _msg = _internal_mutable_texturedisplacement();
  // @@protoc_insertion_point(field_mutable:KuplungApp.MeshModelMaterial.TextureDisplacement)
  return _msg;
}
inline void MeshModelMaterial::set_allocated_texturedisplacement(::KuplungApp::MeshMaterialTextureImage* texturedisplacement) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.texturedisplacement_;
  }
  if (texturedisplacement) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(texturedisplacement);
    if (message_arena != submessage_arena) {
      texturedisplacement = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, texturedisplacement, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.texturedisplacement_ = texturedisplacement;
  // @@protoc_insertion_point(field_set_allocated:KuplungApp.MeshModelMaterial.TextureDisplacement)
}

// -------------------------------------------------------------------

// Mesh

// required int32 ID = 1;
inline bool Mesh::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Mesh::has_id() const {
  return _internal_has_id();
}
inline void Mesh::clear_id() {
  _impl_.id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t Mesh::_internal_id() const {
  return _impl_.id_;
}
inline int32_t Mesh::id() const {
  // @@protoc_insertion_point(field_get:KuplungApp.Mesh.ID)
  return _internal_id();
}
inline void Mesh::_internal_set_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.id_ = value;
}
inline void Mesh::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:KuplungApp.Mesh.ID)
}

// required .KuplungApp.FBEntity File = 2;
inline bool Mesh::_internal_has_file() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.file_ != nullptr);
  return value;
}
inline bool Mesh::has_file() const {
  return _internal_has_file();
}
inline void Mesh::clear_file() {
  if (_impl_.file_ != nullptr) _impl_.file_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::KuplungApp::FBEntity& Mesh::_internal_file() const {
  const ::KuplungApp::FBEntity* p = _impl_.file_;
  return p != nullptr ? *p : reinterpret_cast<const ::KuplungApp::FBEntity&>(
      ::KuplungApp::_FBEntity_default_instance_);
}
inline const ::KuplungApp::FBEntity& Mesh::file() const {
  // @@protoc_insertion_point(field_get:KuplungApp.Mesh.File)
  return _internal_file();
}
inline void Mesh::unsafe_arena_set_allocated_file(
    ::KuplungApp::FBEntity* file) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.file_);
  }
  _impl_.file_ = file;
  if (file) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KuplungApp.Mesh.File)
}
inline ::KuplungApp::FBEntity* Mesh::release_file() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::KuplungApp::FBEntity* temp = _impl_.file_;
  _impl_.file_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::KuplungApp::FBEntity* Mesh::unsafe_arena_release_file() {
  // @@protoc_insertion_point(field_release:KuplungApp.Mesh.File)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::KuplungApp::FBEntity* temp = _impl_.file_;
  _impl_.file_ = nullptr;
  return temp;
}
inline ::KuplungApp::FBEntity* Mesh::_internal_mutable_file() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.file_ == nullptr) {
    auto* p = CreateMaybeMessage<::KuplungApp::FBEntity>(GetArenaForAllocation());
    _impl_.file_ = p;
  }
  return _impl_.file_;
}
inline ::KuplungApp::FBEntity* Mesh::mutable_file() {
  ::KuplungApp::FBEntity* _msg = _internal_mutable_file();
  // @@protoc_insertion_point(field_mutable:KuplungApp.Mesh.File)
  return _msg;
}
inline void Mesh::set_allocated_file(::KuplungApp::FBEntity* file) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.file_;
  }
  if (file) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(file);
    if (message_arena != submessage_arena) {
      file = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, file, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.file_ = file;
  // @@protoc_insertion_point(field_set_allocated:KuplungApp.Mesh.File)
}

// required string ModelTitle = 3;
inline bool Mesh::_internal_has_modeltitle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Mesh::has_modeltitle() const {
  return _internal_has_modeltitle();
}
inline void Mesh::clear_modeltitle() {
  _impl_.modeltitle_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Mesh::modeltitle() const {
  // @@protoc_insertion_point(field_get:KuplungApp.Mesh.ModelTitle)
  return _internal_modeltitle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Mesh::set_modeltitle(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.modeltitle_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:KuplungApp.Mesh.ModelTitle)
}
inline std::string* Mesh::mutable_modeltitle() {
  std::string* _s = _internal_mutable_modeltitle();
  // @@protoc_insertion_point(field_mutable:KuplungApp.Mesh.ModelTitle)
  return _s;
}
inline const std::string& Mesh::_internal_modeltitle() const {
  return _impl_.modeltitle_.Get();
}
inline void Mesh::_internal_set_modeltitle(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.modeltitle_.Set(value, GetArenaForAllocation());
}
inline std::string* Mesh::_internal_mutable_modeltitle() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.modeltitle_.Mutable(GetArenaForAllocation());
}
inline std::string* Mesh::release_modeltitle() {
  // @@protoc_insertion_point(field_release:KuplungApp.Mesh.ModelTitle)
  if (!_internal_has_modeltitle()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.modeltitle_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.modeltitle_.IsDefault()) {
    _impl_.modeltitle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Mesh::set_allocated_modeltitle(std::string* modeltitle) {
  if (modeltitle != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.modeltitle_.SetAllocated(modeltitle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.modeltitle_.IsDefault()) {
    _impl_.modeltitle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KuplungApp.Mesh.ModelTitle)
}

// required string MaterialTitle = 4;
inline bool Mesh::_internal_has_materialtitle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Mesh::has_materialtitle() const {
  return _internal_has_materialtitle();
}
inline void Mesh::clear_materialtitle() {
  _impl_.materialtitle_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Mesh::materialtitle() const {
  // @@protoc_insertion_point(field_get:KuplungApp.Mesh.MaterialTitle)
  return _internal_materialtitle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Mesh::set_materialtitle(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.materialtitle_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:KuplungApp.Mesh.MaterialTitle)
}
inline std::string* Mesh::mutable_materialtitle() {
  std::string* _s = _internal_mutable_materialtitle();
  // @@protoc_insertion_point(field_mutable:KuplungApp.Mesh.MaterialTitle)
  return _s;
}
inline const std::string& Mesh::_internal_materialtitle() const {
  return _impl_.materialtitle_.Get();
}
inline void Mesh::_internal_set_materialtitle(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.materialtitle_.Set(value, GetArenaForAllocation());
}
inline std::string* Mesh::_internal_mutable_materialtitle() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.materialtitle_.Mutable(GetArenaForAllocation());
}
inline std::string* Mesh::release_materialtitle() {
  // @@protoc_insertion_point(field_release:KuplungApp.Mesh.MaterialTitle)
  if (!_internal_has_materialtitle()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.materialtitle_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.materialtitle_.IsDefault()) {
    _impl_.materialtitle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Mesh::set_allocated_materialtitle(std::string* materialtitle) {
  if (materialtitle != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.materialtitle_.SetAllocated(materialtitle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.materialtitle_.IsDefault()) {
    _impl_.materialtitle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KuplungApp.Mesh.MaterialTitle)
}

// required int32 countVertices = 5;
inline bool Mesh::_internal_has_countvertices() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Mesh::has_countvertices() const {
  return _internal_has_countvertices();
}
inline void Mesh::clear_countvertices() {
  _impl_.countvertices_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int32_t Mesh::_internal_countvertices() const {
  return _impl_.countvertices_;
}
inline int32_t Mesh::countvertices() const {
  // @@protoc_insertion_point(field_get:KuplungApp.Mesh.countVertices)
  return _internal_countvertices();
}
inline void Mesh::_internal_set_countvertices(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.countvertices_ = value;
}
inline void Mesh::set_countvertices(int32_t value) {
  _internal_set_countvertices(value);
  // @@protoc_insertion_point(field_set:KuplungApp.Mesh.countVertices)
}

// required int32 countTextureCoordinates = 6;
inline bool Mesh::_internal_has_counttexturecoordinates() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Mesh::has_counttexturecoordinates() const {
  return _internal_has_counttexturecoordinates();
}
inline void Mesh::clear_counttexturecoordinates() {
  _impl_.counttexturecoordinates_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int32_t Mesh::_internal_counttexturecoordinates() const {
  return _impl_.counttexturecoordinates_;
}
inline int32_t Mesh::counttexturecoordinates() const {
  // @@protoc_insertion_point(field_get:KuplungApp.Mesh.countTextureCoordinates)
  return _internal_counttexturecoordinates();
}
inline void Mesh::_internal_set_counttexturecoordinates(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.counttexturecoordinates_ = value;
}
inline void Mesh::set_counttexturecoordinates(int32_t value) {
  _internal_set_counttexturecoordinates(value);
  // @@protoc_insertion_point(field_set:KuplungApp.Mesh.countTextureCoordinates)
}

// required int32 countNormals = 7;
inline bool Mesh::_internal_has_countnormals() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Mesh::has_countnormals() const {
  return _internal_has_countnormals();
}
inline void Mesh::clear_countnormals() {
  _impl_.countnormals_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline int32_t Mesh::_internal_countnormals() const {
  return _impl_.countnormals_;
}
inline int32_t Mesh::countnormals() const {
  // @@protoc_insertion_point(field_get:KuplungApp.Mesh.countNormals)
  return _internal_countnormals();
}
inline void Mesh::_internal_set_countnormals(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.countnormals_ = value;
}
inline void Mesh::set_countnormals(int32_t value) {
  _internal_set_countnormals(value);
  // @@protoc_insertion_point(field_set:KuplungApp.Mesh.countNormals)
}

// required int32 countIndices = 8;
inline bool Mesh::_internal_has_countindices() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Mesh::has_countindices() const {
  return _internal_has_countindices();
}
inline void Mesh::clear_countindices() {
  _impl_.countindices_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline int32_t Mesh::_internal_countindices() const {
  return _impl_.countindices_;
}
inline int32_t Mesh::countindices() const {
  // @@protoc_insertion_point(field_get:KuplungApp.Mesh.countIndices)
  return _internal_countindices();
}
inline void Mesh::_internal_set_countindices(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.countindices_ = value;
}
inline void Mesh::set_countindices(int32_t value) {
  _internal_set_countindices(value);
  // @@protoc_insertion_point(field_set:KuplungApp.Mesh.countIndices)
}

// required .KuplungApp.MeshModelMaterial ModelMaterial = 9;
inline bool Mesh::_internal_has_modelmaterial() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.modelmaterial_ != nullptr);
  return value;
}
inline bool Mesh::has_modelmaterial() const {
  return _internal_has_modelmaterial();
}
inline void Mesh::clear_modelmaterial() {
  if (_impl_.modelmaterial_ != nullptr) _impl_.modelmaterial_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::KuplungApp::MeshModelMaterial& Mesh::_internal_modelmaterial() const {
  const ::KuplungApp::MeshModelMaterial* p = _impl_.modelmaterial_;
  return p != nullptr ? *p : reinterpret_cast<const ::KuplungApp::MeshModelMaterial&>(
      ::KuplungApp::_MeshModelMaterial_default_instance_);
}
inline const ::KuplungApp::MeshModelMaterial& Mesh::modelmaterial() const {
  // @@protoc_insertion_point(field_get:KuplungApp.Mesh.ModelMaterial)
  return _internal_modelmaterial();
}
inline void Mesh::unsafe_arena_set_allocated_modelmaterial(
    ::KuplungApp::MeshModelMaterial* modelmaterial) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modelmaterial_);
  }
  _impl_.modelmaterial_ = modelmaterial;
  if (modelmaterial) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KuplungApp.Mesh.ModelMaterial)
}
inline ::KuplungApp::MeshModelMaterial* Mesh::release_modelmaterial() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::KuplungApp::MeshModelMaterial* temp = _impl_.modelmaterial_;
  _impl_.modelmaterial_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::KuplungApp::MeshModelMaterial* Mesh::unsafe_arena_release_modelmaterial() {
  // @@protoc_insertion_point(field_release:KuplungApp.Mesh.ModelMaterial)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::KuplungApp::MeshModelMaterial* temp = _impl_.modelmaterial_;
  _impl_.modelmaterial_ = nullptr;
  return temp;
}
inline ::KuplungApp::MeshModelMaterial* Mesh::_internal_mutable_modelmaterial() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.modelmaterial_ == nullptr) {
    auto* p = CreateMaybeMessage<::KuplungApp::MeshModelMaterial>(GetArenaForAllocation());
    _impl_.modelmaterial_ = p;
  }
  return _impl_.modelmaterial_;
}
inline ::KuplungApp::MeshModelMaterial* Mesh::mutable_modelmaterial() {
  ::KuplungApp::MeshModelMaterial* _msg = _internal_mutable_modelmaterial();
  // @@protoc_insertion_point(field_mutable:KuplungApp.Mesh.ModelMaterial)
  return _msg;
}
inline void Mesh::set_allocated_modelmaterial(::KuplungApp::MeshModelMaterial* modelmaterial) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.modelmaterial_;
  }
  if (modelmaterial) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(modelmaterial);
    if (message_arena != submessage_arena) {
      modelmaterial = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, modelmaterial, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.modelmaterial_ = modelmaterial;
  // @@protoc_insertion_point(field_set_allocated:KuplungApp.Mesh.ModelMaterial)
}

// repeated .KuplungApp.Vec3 vertices = 10;
inline int Mesh::_internal_vertices_size() const {
  return _impl_.vertices_.size();
}
inline int Mesh::vertices_size() const {
  return _internal_vertices_size();
}
inline void Mesh::clear_vertices() {
  _impl_.vertices_.Clear();
}
inline ::KuplungApp::Vec3* Mesh::mutable_vertices(int index) {
  // @@protoc_insertion_point(field_mutable:KuplungApp.Mesh.vertices)
  return _impl_.vertices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::KuplungApp::Vec3 >*
Mesh::mutable_vertices() {
  // @@protoc_insertion_point(field_mutable_list:KuplungApp.Mesh.vertices)
  return &_impl_.vertices_;
}
inline const ::KuplungApp::Vec3& Mesh::_internal_vertices(int index) const {
  return _impl_.vertices_.Get(index);
}
inline const ::KuplungApp::Vec3& Mesh::vertices(int index) const {
  // @@protoc_insertion_point(field_get:KuplungApp.Mesh.vertices)
  return _internal_vertices(index);
}
inline ::KuplungApp::Vec3* Mesh::_internal_add_vertices() {
  return _impl_.vertices_.Add();
}
inline ::KuplungApp::Vec3* Mesh::add_vertices() {
  ::KuplungApp::Vec3* _add = _internal_add_vertices();
  // @@protoc_insertion_point(field_add:KuplungApp.Mesh.vertices)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::KuplungApp::Vec3 >&
Mesh::vertices() const {
  // @@protoc_insertion_point(field_list:KuplungApp.Mesh.vertices)
  return _impl_.vertices_;
}

// repeated .KuplungApp.Vec2 texture_coordinates = 11;
inline int Mesh::_internal_texture_coordinates_size() const {
  return _impl_.texture_coordinates_.size();
}
inline int Mesh::texture_coordinates_size() const {
  return _internal_texture_coordinates_size();
}
inline void Mesh::clear_texture_coordinates() {
  _impl_.texture_coordinates_.Clear();
}
inline ::KuplungApp::Vec2* Mesh::mutable_texture_coordinates(int index) {
  // @@protoc_insertion_point(field_mutable:KuplungApp.Mesh.texture_coordinates)
  return _impl_.texture_coordinates_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::KuplungApp::Vec2 >*
Mesh::mutable_texture_coordinates() {
  // @@protoc_insertion_point(field_mutable_list:KuplungApp.Mesh.texture_coordinates)
  return &_impl_.texture_coordinates_;
}
inline const ::KuplungApp::Vec2& Mesh::_internal_texture_coordinates(int index) const {
  return _impl_.texture_coordinates_.Get(index);
}
inline const ::KuplungApp::Vec2& Mesh::texture_coordinates(int index) const {
  // @@protoc_insertion_point(field_get:KuplungApp.Mesh.texture_coordinates)
  return _internal_texture_coordinates(index);
}
inline ::KuplungApp::Vec2* Mesh::_internal_add_texture_coordinates() {
  return _impl_.texture_coordinates_.Add();
}
inline ::KuplungApp::Vec2* Mesh::add_texture_coordinates() {
  ::KuplungApp::Vec2* _add = _internal_add_texture_coordinates();
  // @@protoc_insertion_point(field_add:KuplungApp.Mesh.texture_coordinates)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::KuplungApp::Vec2 >&
Mesh::texture_coordinates() const {
  // @@protoc_insertion_point(field_list:KuplungApp.Mesh.texture_coordinates)
  return _impl_.texture_coordinates_;
}

// repeated .KuplungApp.Vec3 normals = 12;
inline int Mesh::_internal_normals_size() const {
  return _impl_.normals_.size();
}
inline int Mesh::normals_size() const {
  return _internal_normals_size();
}
inline void Mesh::clear_normals() {
  _impl_.normals_.Clear();
}
inline ::KuplungApp::Vec3* Mesh::mutable_normals(int index) {
  // @@protoc_insertion_point(field_mutable:KuplungApp.Mesh.normals)
  return _impl_.normals_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::KuplungApp::Vec3 >*
Mesh::mutable_normals() {
  // @@protoc_insertion_point(field_mutable_list:KuplungApp.Mesh.normals)
  return &_impl_.normals_;
}
inline const ::KuplungApp::Vec3& Mesh::_internal_normals(int index) const {
  return _impl_.normals_.Get(index);
}
inline const ::KuplungApp::Vec3& Mesh::normals(int index) const {
  // @@protoc_insertion_point(field_get:KuplungApp.Mesh.normals)
  return _internal_normals(index);
}
inline ::KuplungApp::Vec3* Mesh::_internal_add_normals() {
  return _impl_.normals_.Add();
}
inline ::KuplungApp::Vec3* Mesh::add_normals() {
  ::KuplungApp::Vec3* _add = _internal_add_normals();
  // @@protoc_insertion_point(field_add:KuplungApp.Mesh.normals)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::KuplungApp::Vec3 >&
Mesh::normals() const {
  // @@protoc_insertion_point(field_list:KuplungApp.Mesh.normals)
  return _impl_.normals_;
}

// repeated fixed32 indices = 13;
inline int Mesh::_internal_indices_size() const {
  return _impl_.indices_.size();
}
inline int Mesh::indices_size() const {
  return _internal_indices_size();
}
inline void Mesh::clear_indices() {
  _impl_.indices_.Clear();
}
inline uint32_t Mesh::_internal_indices(int index) const {
  return _impl_.indices_.Get(index);
}
inline uint32_t Mesh::indices(int index) const {
  // @@protoc_insertion_point(field_get:KuplungApp.Mesh.indices)
  return _internal_indices(index);
}
inline void Mesh::set_indices(int index, uint32_t value) {
  _impl_.indices_.Set(index, value);
  // @@protoc_insertion_point(field_set:KuplungApp.Mesh.indices)
}
inline void Mesh::_internal_add_indices(uint32_t value) {
  _impl_.indices_.Add(value);
}
inline void Mesh::add_indices(uint32_t value) {
  _internal_add_indices(value);
  // @@protoc_insertion_point(field_add:KuplungApp.Mesh.indices)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
Mesh::_internal_indices() const {
  return _impl_.indices_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
Mesh::indices() const {
  // @@protoc_insertion_point(field_list:KuplungApp.Mesh.indices)
  return _internal_indices();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
Mesh::_internal_mutable_indices() {
  return &_impl_.indices_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
Mesh::mutable_indices() {
  // @@protoc_insertion_point(field_mutable_list:KuplungApp.Mesh.indices)
  return _internal_mutable_indices();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace KuplungApp

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_KuplungDefinitions_2eproto
