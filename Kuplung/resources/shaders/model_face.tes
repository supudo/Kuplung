#version 410

layout(triangles, equal_spacing, cw) in;

uniform mat4 vs_MVPMatrix;

in vec3 tes_vertexPosition[];
in vec2 tes_textureCoord[];
in vec3 tes_vertexNormal[];
in vec3 tes_displacementLocation[];
in float tes_isBorder[];

out VS_OUT {
    vec3 gs_vertexPosition;
    vec2 gs_textureCoord;
    vec3 gs_vertexNormal;
    vec3 gs_displacementLocation;
    float gs_isBorder;
} vs_out;

vec2 interpolate2D(vec2 v0, vec2 v1, vec2 v2) {
    return vec2(gl_TessCoord.x) * v0 + vec2(gl_TessCoord.y) * v1 + vec2(gl_TessCoord.z) * v2;
}

vec3 interpolate3D(vec3 v0, vec3 v1, vec3 v2) {
    return vec3(gl_TessCoord.x) * v0 + vec3(gl_TessCoord.y) * v1 + vec3(gl_TessCoord.z) * v2;
}

void main() {
    vec3 p0 = gl_TessCoord.x * tes_vertexPosition[0];
    vec3 p1 = gl_TessCoord.y * tes_vertexPosition[1];
    vec3 p2 = gl_TessCoord.z * tes_vertexPosition[2];
    vs_out.gs_vertexPosition = normalize(p0 + p1 + p2);

    vs_out.gs_textureCoord = interpolate2D(tes_textureCoord[0], tes_textureCoord[1], tes_textureCoord[2]);
    vs_out.gs_vertexNormal = interpolate3D(tes_vertexNormal[0], tes_vertexNormal[1], tes_vertexNormal[2]);
    vs_out.gs_displacementLocation = interpolate3D(tes_displacementLocation[0], tes_displacementLocation[1], tes_displacementLocation[2]);
    vs_out.gs_isBorder = tes_isBorder[0];
}
